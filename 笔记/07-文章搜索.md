

# 文章搜索

> 在搜索中心，可以输入关键字
> 关键字还会联想一些其他关键字内容
> 然后根据一个指定的关键字做文章模糊搜索输出

# 页面布局

`目标`：

​	完成搜索页面的整体布局效果

`知识点`：

搜索框组件

```html
<van-search
            v-model="value" // 双向数据绑定，感知/设置 相关内容
            placeholder="请输入搜索关键词"
            />
```

> 本质就是一个**输入框**加上一个搜索的**图标**



单元格

```html
<van-cell-group>
  <van-cell title="单元格" icon="search" />
  <van-cell title="单元格" icon="search" />
</van-cell-group>
```

> title：单元格内容
>
> icon：单元格图标





`步骤`：

1. 搜索组件search/index.vue，内容如下

   ```vue
   <template>
     <div class="container">
       <!-- 自己的导航栏
       left-arrow：左侧有箭头
       @click-left：单击左侧箭头的事件处理
       $router.back() 执行路由的后退操作
       -->
       <van-nav-bar title="搜索中心" left-arrow @click-left="$router.back()"/>
       <!-- 搜索输入框 -->
       <van-search v-model.trim="searchText" placeholder="请输入搜索关键词"/>
       <van-cell-group>
         <van-cell title="联想关键字" icon="search"></van-cell>
         <van-cell title="联想关键字" icon="search"></van-cell>
         <van-cell title="联想关键字" icon="search"></van-cell>
         <van-cell title="联想关键字" icon="search"></van-cell>
         <van-cell title="联想关键字" icon="search"></van-cell>
         <van-cell title="联想关键字" icon="search"></van-cell>
       </van-cell-group>
     </div>
   </template>
   
   <script>
   export default {
     name: 'search-index',
     data () {
       return {
         searchText: '' // 用户输入的搜索关键字
       }
     }
   }
   </script>
   
   <style scoped lang='less'></style>
   
   ```
   
   
   
2. 配置路由  src/router/index.js

   (之前已经配置好，了解即可)

   ```js
   {
     path: '/search',
     component: () => import('@/views/search') // 搜索中心
   },
   ```
   
3. 在layout/index.vue中给“搜索”按钮设置单击事件

   (之前已经配置好，了解即可)

   ```vue
   <van-nav-bar 
         fixed title="黑马头条" 
         right-text="搜索"
      		@click-right="$router.push('/search')"/>
   ```

   > right-text:设置导航右侧部分的内容
   >
   > @click-right:单击导航右侧部分内容触发的事件

`效果`：

![1583823939409](img(online)/1583823939409.png)



`注意`：

​	搜索页面不同于home页面，其是独立的页面，不是layout的子级了



# 搜索

## 联想数据获取并渲染

>     联想关键字来自服务器端
>     根据用户输入的关键字，联想其他的关键字展示
>     api-->获得数据
>     
>     实施：
>     1. 创建api  (api/search.js---->apiSearchSugguestion)
>     2. 业务组件[search/index.js]做相关逻辑
>         A. 导入api--->什么时候调用---->搜索框内容有变化后
>         B. 给搜索框v-model成员设置【watch监听】，调用api
>     
>         C. 创建data成员，接收联想建议数据结果
>         D. 模板遍历输出data成员

`目标`：

​	获取联想建议的数据，并且展示出来



`步骤`：

1. 创建  api/search.js  文件，知道函数实现 获得联想建议数据

   接口：【获取联想建议（自动补全）】

   ```js
   // 导入axios
   import request from '@/utils/request.js'
   
   // 搜索相关的api函数制作
   /**
    * 根据用户输入信息，获得联想关键字
    * @param {用户输入的关键字} q
    */
   export function apiSearchSuggestion (q) {
     return request({
       url: '/app/v1_0/suggestion',
       method: 'get',
       params: {
         q
       }
     })
   }
   
   ```

   

2. search/index.vue  处理

   A. import引入api方法 

   B. 给搜索关键字设置watch监听器，用户有输入内容就做联想搜索

   C. 创建data成员suggestionList

   D. 遍历展示联想到的内容

   ```vue
   <!-- 联想建议 -->
   <van-cell-group>
     <!--4. 遍历展示-->
     <van-cell
               :title="item"
               icon="search"
               v-for="(item,k) in suggestionList"
               :key="k"
               />
   </van-cell-group>
   
   <script>
   // 1. 导入api函数
   import { apiSuggestionList } from '@/api/search'
   export default {
     name: 'search-index',
     watch: {
       // 2. 对关键字做监听，有变化就要获取联想数据
       // searchText进行监听
       searchText: async function (newV) {
         // 用户没有输入信息不要联想
         if (!newV) {
           // 去除旧的联想数据
           this.suggestionList = []
           return false
         }
   
         // 正常联想
         const result = await apiSearchSuggestion(newV)
         // console.log(result)
         // data接收
         this.suggestionList = result.options
       }
     }
     data () {
       return {
         suggestionList: [], // 3. 联想建议数据
         searchText: '' // 搜索关键字
       }
     }
   }
   ```




`效果`：

![1580469167635](img(online)/1580469167635.png)



`注意`：

​	汉字经http地址栏传递，要被转码的，转码的效果是%后跟两个**16进制数**，一个字节对应一个%，一个汉字是3个字节，就对应3个%，虽然被转码，不影响使用

​	![1581925299148](img(online)/1581925299148.png)

​	例如：你好-----> %E4%BD%A0%E5%A5%BD

​	



## 防抖处理

> 在搜索框输入内容，会触发内容改变事件执行(watch监听器)
> 短时间之内，输入多个关键字，那么事件就被"频繁"执行，这是“抖动”现象
> 我们不想要这个现象，需要的就是内容输入完毕，执行一次事件即可
> 防抖：短时间之内，要频繁发生的事件，我们只让最后一次来执行，就是“防抖”
>
> 防抖处理：
> setTimeout + clearTimeout，实现事件的开启和停止



> 用户在搜索框中输入关键字，没等完毕，服务器会**立即**去检索，反应时间很短，甚至每输入一个字符，就检索一次，非常频繁
>
> 我们希望的结果是在**相对的时间范围内**等用户把内容都输入完毕再去检索，这样既提高了用户体验，还节省服务器资源

`目标`：

​	不要让搜索过于频繁



`抖动和防抖`

​	短时间内频繁触发同一事件，就是**抖动**

​	短时间内频繁触发同一事件，但只执行最后或开始的一次，就是**防抖**

​	短时间内频繁触发同一事件，只执行最后一次，或者只执行最开始的一次，中间的不执行



抖动缺点：

1. 动作过于频繁，没有必要，造成资源浪费
2. dom频繁操作，容易使得浏览器崩溃



抖动处理：

通过定时器函数对watch监听器进行升级、改造为如下

(setTimeout/clearTimeout)

```js
  watch: {
    // searchText进行监听
    searchText: function (newV) {
      // 该监听器每次进来的时候，首先清除 this.timer（就是setTimeout停止）定时器
      clearTimeout(this.timer)
      // 用户没有输入信息不要联想
      if (!newV) {
        // 去除旧的联想数据
        this.suggestionList = []
        return false
      }

      // 防抖技术要介入
      // 对setTimeout的返回结果进行接收，以便可以中断其执行
      // 会返回"整型数字"信息
      // 给当前组件临时声明一个timer的临时成员，这个成员不用事先通过data声明
      // 组件运行期间都生效，使得就是唯一的timer被使用(即使事件被多次调用)
      this.timer = setTimeout(async () => {
        // 正常联想
        const result = await apiSearchSuggestion(newV)
        // console.log(result)
        // data接收
        this.suggestionList = result.options
      }, 1000)
    }
  },
```

现在的效果是  关键字内容输入完毕1s后  才向服务器端发请求获得联想内容，如果连续输入关键字，并且间隔不足1s，则不发送请求



`注意`：

1. **this.timer**表示给 组件实例 动态增加一个data成员，临时使用的可以不用提前声明

2. 因为setTimeout介入，注意把async放到setTimeout内部的function前边

 

## 关键字高亮

> 根据用户输入内容，给联想数据关键字部分设置高亮显示
> 原理：css样式控制 \<span style="color:red"\>vue\</span\>本地项目获s
> 大原则，通过 正则表达式 对目标内容进行"匹配"，让后"替换"为红色
>
> 模板内容要做红色高亮设置
> 要应用methods方法
>
> 高亮显示有时候会报错
> 原因：联想的数据有时候和关键字是不匹配的
>       这样做高亮设置是不妥的

`目标`：

​	为了用户提交好，给联想建议词条中的关键字设置为css样式高亮效果

`步骤`：

​	在 search/index.vue 中进行如下

1. 创建methods方法，设置搜索关键字高亮

   ```js
     methods: {
       // 关键字高亮设置
       // content: 要高亮设置的目标内容[vue本地项目]
       // keywords: 被匹配的关键字[Vue]
       highLightCell (content, keywords) {
         // 1. 创建正则，i修饰符，表示忽略大小写
         //    A. /  / 方式
         //    B. new RegExp()方式
         //    const reg = /\d{5}/i  或  const reg = new RegExp('\d{5}','i')
         //    由于正则主体内容是keywords变量，不方便使用//创建，相反送RegExp就比较合适
         const reg = new RegExp(keywords, 'i')
   
         // 2. 正则与目标内容进行匹配
         //    A. test()返回是否匹配到的Boolean值
         //    B. match()返回匹配到的结果（对象、null）
         // 因为要获得匹配到的内容，所以要使用match方法
         // 语法：目标内容.match(正则)
         const rst = content.match(reg)
         // console.log(rst) // ["vue", index: 0, input: "vue本地项目获s", groups: undefined]
         // 结论：
         // rst[0]： 就是从目标内容中匹配到关键字信息【重点】
         // rst['index']：关键字出现的下标位置
         // rst['input']：代表完整的目标内容
   
         // 如果目标内容没有匹配到关键字，就不要做高亮了，原样输出即可
         if (rst === null) {
           return content
         }
   
         // 3. 对目标内容的关键字做替换，把"普通"的关键字变为"高亮"的关键字
         // 字符串.replace(目标关键字，替换内容)
         // content.replace('vue'，'<span style="color:red;">vue</span>')
         // content.replace(正则，'<span style="color:red;">rst[0]</span>')
         return content.replace(reg, `<span style="color:red;">${rst[0]}</span>`)
       }
     }
   ```

   

2. 联想单元格通过v-html显示 高亮的内容，同时要调用 methods方法

   ```html
   <!-- 联想关键字内容展示列表 -->
   <van-cell icon="search" v-for="(item,k) in suggestionList" :key="k">
     <!-- 应为要应用methods方法，并且该方法返回的信息里边有 html标签+css样式
   所以不要直接使用title属性，相反要应用命名插槽，内部结合v-html应用 -->
     <div slot="title" v-html="highLightCell(item,searchText)"></div>
   </van-cell>
   ```
   
   > 注意：
   >
   > 1. 给cell单元格设置title标题信息，有两种方式：①title属性  ②slot="title"命名插槽
   >
   > 2. 当对关键字做高亮处理后，内容中就出现"html标签"和"css样式"信息，这样就决定了必须使用v-html之Vue指令，其可以使得html标签和css样式被浏览器解析，这样使得**②命名插槽**填充标题方式被采纳
   >
   > 3. 对关键字做高亮可以有两种方式：methods方法、filter过滤器，我们采用methods方法，因为filter过滤器不能在v-html里边使用

   




`效果`：

![1581843865939](img(online)/1581843865939.png)

`注意`：

1. 关键字如果是英文字母，无论大写还是小写关键字都给处理为对应的高亮效果，大写--->大写高亮    小写--->小写高亮
2. 组件中通过v-html调用methods方法显示内容，可以使得浏览器解析高亮的**html标签**和**css样式**
3. 如果内容中没有html标签和css样式，倒是可以对van-cell单元格的title属性直接操作





## 搜索结果

根据**关键字**检索相关的文章

### 展示页面

>         关注：关键字体现，具体通过路由地址体现
>         路由地址有参数，形式为params，具体是路由参数
>         参数有两种形式：
>         params: /#/search/result/yy // yy就是给当前路由传递的参数
>         query:/#/search/result?xx=yy&kk=ww 之前学习的"请求字符串"
>     
>         当前应用方式为【params】
>     
>         我们要应用params方式传递关键字参数
>         A. 路由设定语法：
>             {path:'/search/result/:名称/:eee/:tt', component:组件}
>             通过:冒号给参数设置名称,可以设置多个
>         B. 路由应用，必须要传递对应的参数
>             this.$router.push('/search/result/123')
>         C. 接收路由参数：
>             this.$route.params.名称
>         注意：
>             $route没有r，用于接收路由参数的对象
>             $router有r，用于路由编程式导航的
>     
>         搜索结果页码展示步骤：
>         1. 给路由配置有参数
>         2. 应用路由并传递参数
>            给联想关键字设置@ click事件，进行路由跳转并传参
>            给搜索框设置@ search事件，进行路由跳转并传参

`目标`：

​	把关键字检索文章的页面展示出来

​	在搜索框中**按回车**  或者  **点击联想结果**项目 进入文章搜索结果展示页面，同时**路由传参**体现关键字

`步骤`：

1. search/result.vue 组件，是展示搜索结果的组件，已经创建好，可以直接前往查看

2. 路由调整为如下

   > 增加 有路由参数keyword，代表 搜索关键字
   >
   
   ```js
   {
     // 当前路由通过:设置，有参数，名称为keyword
     path: '/search/result/:keyword',
     component: () => import('@/views/search/result.vue') // 搜索结果
   }
   ```
   
   > 注意：路由有参数，应用的时候必须传递，否则匹配不到了
   
3. search/index.vue中 给搜索框  和  联想结果项目 绑定事件 并传递参数

   > ① van-search有@search事件，单击 回车键  触发
   >
   > ② van-cell有@click，单击 联想项目  触发

   ```html
   <!-- 搜索输入框
   .trim: 是vue框架修饰符，要去除内容左右空白
   @search: 搜索框单击“回车按钮”的事件触发
   -->
   <van-search v-model.trim="searchText" placeholder="请输入搜索关键词"
               @search="$router.push('/search/result/'+searchText)"/>
   <van-cell-group>
   
     <!-- 联想关键字内容展示列表 -->
     <van-cell icon="search" v-for="(item,k) in suggestionList" :key="k"
               @click="$router.push('/search/result/'+item)"
               >
   ```
   
   
   

`效果`：

![1580542332510](img(online)/1580542332510.png)

![1580542275589](img(online)/1580542275589.png)

`注意`：

搜索框**按回车**  或  **单击联想项目**都可以携带当前关键字进入到结果展示页面



### 获取数据

`目标`：

​	根据关键字获得搜索文章列表结果



`步骤`：

1. 在 api/search.js 中创建方法，根据关键字获得搜索结果

   接口：【获取搜索结果】

   ```js
   /**
    * 根据联想关键字 搜索文章
    * @param {联想的关键字} q
    * @param {页码} page
    * @param {返回内容条数} per_page
    */
   export function apiSearchList ({ q, page = 1, perPage = 10 }) {
     return request({
       url: '/app/v1_0/search',
       method: 'get',
       params: {
         q,
         page,
         per_page: perPage
       }
     })
   }
   ```
   
> page=1，per_page=10给参数设置默认值

2. search/result.vue 的组件实例部分

   > 1. 导入api
   >
   > 2. data成员
   >
   > 3. methods方法
   >
   > 4. created
   
   ```vue
   <script>
   // 引入api接口
   import { apiSearchList } from '@/api/search'
   
   export default {
     name: 'search-result',
     data () {
       return {
         searchList: [] // 搜索结果
       }
     },
     created () {
       // 调用搜索方法
       this.getSearchList()
     },
     methods: {
       // 获得搜索结果
       async getSearchList () {
         const result = await apiSearchList({ q: this.$route.params.keyword })
         this.searchList = result.results
       }
     }
   }
   </script>
   
   ```
   
   > 组件中获得路由参数格式： this.$route.params.xxx  其中xxx是路由中通过**:冒号**声明的参数名字
   >
   > 注意：
   >
   > ​	$route是vue关键字，可以获得路由参数信息
   >
   > ​	$router也是vue关键字，可以进行路由跳转执行，例如 this.\$router.push('/login')
   >
   > ​	两者不要混淆



现在result.vue中已经可以根据关键字获得搜索结果了(通过devtools查看)

![1580543134947](img(online)/1580543134947.png)



### 内容布局

`目标`：

​	把搜索结果页面**架构**布局设计出来



具体构思就是通过 van-list 、van-cell 设计一个 **瀑布流滚动加载** 效果

van-list和van-cell官网详情： https://youzan.github.io/vant/#/zh-CN/list 

 瀑布流滚动加载，用于展示长列表，当列表即将滚动到底部时，会触发事件并加载更多列表项 

 List 组件通过`loading`和`finished`两个变量控制加载状态，当组件滚动到底部时，会触发`load`事件并将`loading`设置成`true`。此时可以发起异步操作并更新数据，数据更新完毕后，将`loading`设置成`false`即可。若数据已全部加载完毕，则直接将`finished`设置成`true`即可。 



在 `search/result.vue` 组件中做如下处理

1. template 结构：

   > 除了设置瀑布必要的标签，还要给 van-nav-bar 标签设置**fixed**属性，使得固定定位

   ```vue
   <template>
     <div class="container">
       <!--给导航栏设置fixed，使得固定定位-->
       <van-nav-bar fixed title="搜索结果" left-arrow @click-left="$router.back()"/>
       <!-- 瀑布流加载 -->
       <van-list v-model="loading" :finished="finished" finished-text="没有更多了" 
                 @load="onLoad">
         <van-cell v-for="item in list" :key="item" :title="item"/>
       </van-list>
     </div>
   </template>
   
   ```

2. data & methods 成员

   ```js
   data () {
     return {
       // 瀑布相关
       list: [],
       loading: false,
       finished: false,
   
       ……
     }
   },
   ……
   methods: {
     // 瀑布加载
     onLoad () {
       // 异步更新数据
       // setTimeout 仅做示例，真实场景中一般为 ajax 请求
       setTimeout(() => {
         for (let i = 0; i < 10; i++) {
           this.list.push(this.list.length + 1)
         }
   
         // 加载状态结束
         this.loading = false
   
         // 数据全部加载完成
         if (this.list.length >= 40) {
           this.finished = true
         }
       }, 1000)
     },
   	……
   
   ```

3. style样式

   ```vue
   <style lang="less" scoped>
   .container {
     height: 100%;
     display: flex;
     flex-direction: column;
     overflow-y: auto;
     box-sizing: border-box;
     .van-list {
       flex: 1;
       margin-top: 92px;
     }
   }
   </style>
   
   ```

   

效果：

![1580545647137](img(online)/1580545647137.png)

`注意`：

​	这里的瀑布效果 是 demo级别的， 与 之前文章列表用法一致



### 渲染数据

`目标`：

​	将搜索到文章结果数据在页面中展示出来



`实施`：

在`search/result.vue`组件中做如下处理：

1. script设置差异化内容如下：

   > created 、 getSearchList()等临时过程内容已经被注释掉了
   >
   > data：增加page和per_page成员
   >
   > 升级 、改造 onLoad方法

   ```vue
   <script>
   export default {
   	
     data () {
       return {
         ……
         page: 1, // 页码
         perPage: 10, // 条数
         searchList: [] // 搜索结果
       }
     },
     // created () {
     //   this.getSearchList()
     // },
     methods: {
       // 瀑布加载
       async onLoad () {
         await this.$sleep(1000) // 暂停1s，不要太着急加载
   
         let result = await apiSearchList({ 
           q: this.q, page: this.page, per_page: this.per_page 
         })
         // 加载状态结束
         this.loading = false
         
         if (!result.results.length) {
           // 数据全部加载完成
           this.finished = true
           return false
         }
         // 追加数据
         this.searchList.push(...result.results)
         // 页码累加
         this.page++
       }
   
       // // 获得搜索结果
       // async getSearchList () {
       //   let result = await apiSearchList({ q: this.q, page: this.page, per_page: this.per_page })
       //   this.searchList = result.results
       // }
     }
   }
   </script>

   ```
   
   



2. template结构：

   对获得到的检索结果做遍历展示

   ```vue
   <van-list v-model="loading" :finished="finished" finished-text="没有更多了" 
             @load="onLoad">
     <!--遍历展示搜索到的每个文章信息-->
     <van-cell 
               v-for="item in searchList" 
               :key="item.art_id.toString()" 
               :title="item.title"/>
   </van-list>
   
   ```
   
   

`效果`：

![1580546775660](img(online)/1580546775660.png)



## 联想历史记录

对**联想记录**数据做存储管理

### 页面布局

`目标`：

​	将联想历史记录示例数据页面效果设计出来



`步骤`：

1. 在 search/index.vue 中  通过 van-cell-group、van-cell、van-icon组件绘制历史记录

   ```html
   <!-- 联想建议 -->
   <van-cell-group v-if="suggestionList.length>0">
     ……
   </van-cell-group>
   <van-cell-group v-else>
     <van-cell title="历史记录">
       <!-- 删除图标
         slot="right-icon" 命名插槽 给 cell单元格的右边显示内容(垃圾桶图标)
         name="delete" 垃圾桶图标
         style="line-height:inherit" 设置内容高度与父级一致
       -->
       <van-icon
         @click="isDeleteData=true"
         v-show="!isDeleteData"
         name="delete"
         slot="right-icon"
         style="line-height:inherit"
       ></van-icon>
       <!-- slot="default" 命名插槽  给单元格定义右侧内容 -->
       <div v-show="isDeleteData" slot="default">
         <span style="margin-right:10px">全部删除</span>
         <span @click="isDeleteData=false">完成</span>
       </div>
     </van-cell>
     <!-- 历史联想项目数据展示 -->
     <van-cell title="hello111">
       <!-- 删除按钮 -->
       <van-icon v-show="isDeleteData" slot="right-icon" name="close" 
                 style="line-height:inherit"></van-icon>
     </van-cell>
   </van-cell-group>
   
   ```

   > line-height:inherit：设置行高与父级标签一致
   >
   > 联想建议  和  联想历史记录  通过v-if 和 v-else 做分支显示

2. data 提供布尔属性控制联想建议和历史记录的切换显示

   ```js
   data () {
     return {
       isDeleteData: false // 历史记录开关
       ……
     }
   },
   ```



效果：

![1580548005306](img(online)/1580548005306.png)

![1580548045003](img(online)/1580548045003.png)

### 本地存储

`目标`：

​	利用localStorage持久化存储访问过的联想关键字，以便展示使用



`知识点`：

Set类型，ES6新增，可以看做是集合，与Array非常相似，但是Array每个项目有key和value，而Set每个项目只有key，Set最大特点是可以使得各个成员都是**唯一的**，Set可以和Array一并使用，它们可以互相转化

```js
let s = new Set()  // 实例化一个空的Set对象
let s = new Set([1,2,3,3,3,4,4,5]) // 根据已有数组实例化一个Set对象

s.add(10) 	// 给集合添加一个元素
s.delete(3) // 删除集合元素
s.has(5) 		// 判断集合中是否存在指定元素
s.clear() 	// 清除所有成员，没有返回值。

let arr = Array.from(s) // 通过Set转化一个Array数组结果

```



`步骤`：

在search/index.vue中做如下处理：

1. 创建一个常量，管理联想历史记录在localStorage中key的名称，以方便后续使用

   ```js
   // 设置关键字历史记录的localStorage的key的名称，方便后续使用
   const SH = 'suggest-histories'
   ```
   

   
2. 创建data成员suggestHistories，获得之前存储好的历史记录

   ```js
   data () {
     return {
       // 联想历史记录
       suggestHistories: JSON.parse(localStorage.getItem(SH) || '[]'),
       ……
     }
   },
   ```

   > 判断本地如果有数据直接使用，否则设置[]空数组

3. 在onSearch()方法中，存储访问的历史记录

   需要借助Set，其可以使得相同的**关键字**只保存一份

   ```js
   // 跳转到搜索结果页面
   onSearch (keywords) {
     // 没有联想内容，停止后续处理
     if (!keywords) { return false }
   
     const st = new Set(this.suggestHistories) // 根据已有的历史记录创建Set对象
     st.add(kw) // 给Set集合填充新元素
     this.suggestHistories = Array.from(st) // 把Set集合转为Array
   
     // 把联想关键字数组存储给localStorage里边
     localStorage.setItem(SH, JSON.stringify(this.suggestHistories))
   
     // 路由跳转
     this.$router.push({ name: 'result', params: { q: keywords } })
   },
   ```
   
   > Set可以保证相同的联想关键字只存储一份，有自动 **去重** 功能
4. 模板中把历史记录展示出来

   ```vue
   <!-- 历史联想展示 -->
   <van-cell :title="item" v-for="(item,k) in suggestHistories" :key="k">
   ```

   > 直接对 suggestHistories 做遍历展示



`效果`：

![1580549920505](img(online)/1580549920505.png)



### 删除

`目标`：

​	实现删除搜索历史记录功能



在`search/index.vue`中做如下处理

1. 给 全部删除 和 单个项目 设置删除的click事件

   ```vue
   <span style="margin-right:10px" @click="delAllSuggest()">全部删除</span>
   ……
   
   <!-- 删除按钮 -->
   <van-icon
             v-show="isDeleteData"
             slot="right-icon"
             name="close"
             style="line-height:inherit"
             @click="delSuggest(k)"
             ></van-icon>
   
   ```

   

2. 制作删除的methods方法

   ```js
   // 删除“全部”联想建议历史记录
   suggestDelAll () {
     this.suggestHistories = []
     localStorage.removeItem(SH)
   },
   
     // 删除“单个”的联想建议历史记录
     suggestDel (index) {
       this.suggestHistories.splice(index, 1)
       // 更新localStorage数据
       localStorage.setItem(SH, JSON.stringify(this.suggestHistories))
     },
   
   ```

   



`效果`：

![1580550723414](img(online)/1580550723414.png)



![1580550751571](img(online)/1580550751571.png)

