# 首页-频道和文章管理



# 布局页面分析

`目标`：

​	清楚各个业务组件的逻辑关系

![1579688895046](img(online)/1579688895046.png)

1. 系统最大的根基组件`App.vue`，里边只有一个路由占位符标签 router-view，用于显示各个业务组件

2. 布局组件`layout/index.vue`，是第二级别组件，本身作为父组件存在，用于显示若干三级业务组件

   内部有使用vant组件库标签

   a. 头部导航效果（[NavBar 导航栏](https://youzan.github.io/vant/#/zh-CN/nav-bar)）

   b. router-view 路由占位符标签

   c. 底部导航（[Tabbar 标签栏](https://youzan.github.io/vant/#/zh-CN/tabbar)）

   ```vue
   <template>
     <div class="container">
       <!--头部导航-->
       <van-nav-bar fixed title="黑马头条" right-text="搜索"
         @click-right="$router.push('/search')"/>
       <div class="my-wrapper" >
         <!--路由占位符-->
         <router-view></router-view>
       </div>
       <!--底部导航-->
       <van-tabbar route>
         <van-tabbar-item to="/" icon="home-o">首页</van-tabbar-item>
         <van-tabbar-item to="/question"  icon="chat-o">问答</van-tabbar-item>
         <van-tabbar-item to="/video"  icon="video-o">视频</van-tabbar-item>
         <van-tabbar-item to="/user"  icon="user-o">我的</van-tabbar-item>
       </van-tabbar>
     </div>
   </template>
   ```

3. home、question、video、user等是第三级组件，它们均在layout里边显示

4. article、search等是第二级别组件，它们均在App.vue里边显示



# 频道标签页组件应用

`目标`：

​	展示简单频道示例数据效果



van-tab 标签页 组件： https://youzan.github.io/vant/#/zh-CN/tab 

语法：

```vue
<van-tabs v-model="下标">
	<van-tab title="标签名称">标签内容</van-tab>
  <van-tab title="标签名称">标签内容</van-tab>
  <van-tab title="标签名称">标签内容</van-tab>
</van-tabs>
```

> v-model通过下标控制激活的标签项目，从0开始计数



应用：

在home/index.vue中设计如下代码：

```vue
<template>
  <div class='container'>
    <!--
      van-tabs:标签页组件
        v-model设置默认激活项目 ，激活根据是项目的下标，从0开始
      van-tab: 标签页项目组件
        title：标签名称
        内容区域：标签对应内容
    -->
    <van-tabs v-model="activeChannelIndex">
      <van-tab title="推荐">推荐内容展示</van-tab>
      <van-tab title="数据库">数据库内容展示</van-tab>
      <van-tab title="后端">后端内容展示</van-tab>
    </van-tabs>
  </div>
</template>

<script>
export default {
  name: 'home-index',
  data () {
    return {
      // 设置频道默认激活项目
      activeChannelIndex: 1
    }
  }
}
</script>

<style scoped lang='less'></style>

```

> 说明：
>
> 通过`v-model`绑定当前激活标签对应的索引值，默认情况下启用第一个标签 ，下标从0开始计数
>
> title：设置频道标签内容
>
> 标签内容：设置当前频道标签激活后对应展示的内容

`效果`：

![1579689229593](img(online)/1579689229593.png)

# 文章展示(上拉瀑布效果)

`目标`：

​	会使用van-list组件，进行简单数据列表展示



van-list 瀑布流滚动加载 组件： https://youzan.github.io/vant/#/zh-CN/list 

文章列表 应用 瀑布流滚动加载组件，该组件具备“**上拉刷新**”功能

 List 组件通过`loading`和`finished`两个变量控制加载状态，当组件滚动到底部时，会触发`load`事件并将`loading`设置成`true`。此时可以发起异步操作并更新数据，数据更新完毕后，将`loading`设置成`false`即可。若数据已全部加载完毕，则直接将`finished`设置成`true`即可 

> loading：设置是否显示 加载 动画
>
> finished：设置是否允许上拉请求



`步骤`：

1. 模板中应用  van-list/van-cell  组件 绘制文章列表示例数据效果
2. 组件实例中 为 上拉组件 创建data成员 和 methods 方法
3. css样式控制



在`home/index.vue`中设计如下代码：

```vue
<!--
van-tabs:标签页组件
v-model设置默认激活项目 ，激活根据是项目的下标，从0开始
van-tab: 标签页项目组件
title：标签名称
内容区域：标签对应内容
-->
<van-tabs v-model="activeChannelIndex">
  <van-tab title="推荐">
    <!-- div的作用是给瀑布流区域设置“垂直滚动条”，使得可以进行上拉操作 -->
    <div class="scroll-wrapper">
      <!-- 瀑布流加载效果实现
瀑布流执行：
1. 页面加载完毕，其会自动执行
(内部会判断当前瀑布区域没有数据，当然要执行获取数据)
2. 鼠标上拉动作，当滚动条到达"算法底部"，会执行
算法底部：瀑布流认为要加载更多数据的位置
v-model="loading"   表明是否是加载状态，默认为false
// 加载的时候，自动设置为true
// 加载完毕，请修改为false
// 是加载动画的体现
:finished  表明瀑布停止了，没有更多数据不给加载了
鼠标上拉已经没有反应了
如果没有数据了，请设置finished为true
就表示都加载好了，显示没有更多了

finished-text="没有更多了"  瀑布流停止，底部文字提示
@load="onLoad"  是事件，是做加载数据的时候执行的
-->
      <van-list v-model="loading" :finished="finished" finished-text="没有更多了" @load="onLoad">
        <!-- van-cell单元格组件
特点：独占一行
用法非常灵活、复杂
title：单元格标题内容
-->
        <van-cell v-for="item in list" :key="item" :title="item"/>
      </van-list>
    </div>

  </van-tab>
  <van-tab title="数据库">数据库内容展示</van-tab>
  <van-tab title="后端">后端内容展示</van-tab>
</van-tabs>
```

> 屏幕被滑动到底部，会自动调用onLoad事件获取更多数据
>
> v-model				是否处于加载状态，加载过程中不触发load事件
> finished				是否已加载完成，加载完成后不再触发load事件
> finished-text		加载完成后的提示文字
> load					   事件，滚动条与底部距离小于 指定阈值  时触发

> scroll-wrapper 固定容器，通过css样式控制能够生成滚动条，将来需要使用滚动动作。

```vue
<script>
export default {
  name: 'home-index',
  data () {
    return {
      // 瀑布流相关成员
      list: [], // 数据源
      loading: false, // 瀑布流是否加载处于动画效果
      finished: false, // 瀑布流是否停止
      // 设置频道默认激活项目
      activeChannelIndex: 0
    }
  },
  methods: {
    // 瀑布流上拉执行的动作
    onLoad () {
      // 异步更新数据
      // setTimeout 仅做示例，真实场景中一般为 ajax 请求
      setTimeout(() => {
        for (let i = 0; i < 10; i++) {
          this.list.push(this.list.length + 1)
        }

        // 加载状态结束
        this.loading = false

        // 数据全部加载完成
        if (this.list.length >= 40) {
          // 已经没有更多了，瀑布停止了
          this.finished = true
        }
      }, 1000)
    }
  }
}
</script>

```



```css
<style scoped lang='less'>
.van-tabs {
  // 弹性布局
  display: flex;
  // 灵活的项目将垂直显示，正如一个列一样
  flex-direction: column;
  height: 100%;
  // 标签页全部内容展示区域
  /deep/ .van-tabs__content {
    // flex:1;的值是1 1 0%，【父控件有剩余空间占1份放大，父控件空间不足按1缩小，自身的空间大小是0%】
    flex: 1;
    overflow: hidden;
  }
  // 标签页具体内容展示区域
  /deep/ .van-tab__pane {
    height: 100%;
    // 给上拉列表区域设置样式
    .scroll-wrapper {
      height: 100%;
      // 瀑布流区域如果垂直方向内容过多，要呈现滚动条
      // 是瀑布实现的关键要素
      overflow-y: auto;
    }
  }
  // 给频道下边沿横向设置样式
  /deep/ .van-tabs__line {
    background-color: #1989fa;
  }
}
</style>
```

> /deep/  深度作用选择器 作用：让样式在子级组件生效。

![1583392992885](img(online)/1583392992885.png)

>     /deep/深度作用选择器
>     业务组件style标签有 “scoped” ，导致组件的全部html标签都会
>     增加 data-v-xxx的唯一属性名称，最终使得css样式达到私有效果
>     
>     业务组件使用的标签有：html标签  +  组件标签
>     1. html标签会增加data-v-xxx的属性
>     2. 组件标签本身会增加data-v-xxx的属性，但是内部编译出来的标签有时“不会”增加data-v-xxx的属性
>     .van-tabs{
>         /deep/ .van-tabs__content 
>     }
>     解析变为： .van-tabs[data-v-xxx] .van-tabs__content{} 【正确】
>     
>     .van-tabs{
>         .van-tabs__content 
>     }
>     解析变为： 理想结果： .van-tabs[data-v-xxx] .van-tabs__content[data-v-xxx] 【错误】
>     				 实际结果： .van-tabs  .van-tabs__content[data-v-xxx] 【错误】
>     
>     .van-tabs .van-tabs__content{}
>     解析变为： .van-tabs[data-v-xxx] .van-tabs__content[data-v-xxx] 【错误】
>     
>     .van-tabs /deep/ .van-tabs__content{}
>     解析变为：.van-tabs[data-v-xxx] .van-tabs__content{}   【正确】
>     
>     结论： /deep/使得标签身上不要设置data-v-xxx的样式属性
>

`效果`：

![1579753158386](img(online)/1579753158386.png)

flex技术说明：

 https://blog.csdn.net/m0_37058714/article/details/80765562 



# 文章组件-独立

`目标`：

​	把文章列表相关代码封装成独立组件，供home首页调用



home首页有许多频道，每个频道下边都有对应的文章列表，封装成独立组件有利于项目后期开发和维护



`步骤`：

1. 创建组件文件  `home/components/com-article.vue`，内容如下

   把home/index.vue中关于文章列表的部分全盘剪切过来，即template、script、style三部分

   ```vue
   <template>
     <!-- div的作用是给瀑布流区域设置“垂直滚动条”，使得可以进行上拉操作 -->
     <div class="scroll-wrapper">
       <!-- 瀑布流加载效果实现
               瀑布流执行：
               1. 页面加载完毕，其会自动执行
                 (内部会判断当前瀑布区域没有数据，当然要执行获取数据)
               2. 鼠标上拉动作，当滚动条到达"算法底部"，会执行
                  算法底部：瀑布流认为要加载更多数据的位置
               v-model="loading"   表明是否是加载状态，默认为false
                                   // 加载的时候，自动设置为true
                                   // 加载完毕，请修改为false
                                   // 是加载动画的体现
               :finished  表明瀑布停止了，没有更多数据不给加载了
                         鼠标上拉已经没有反应了
                         如果没有数据了，请设置finished为true
                         就表示都加载好了，显示没有更多了
   
               finished-text="没有更多了"  瀑布流停止，底部文字提示
               @load="onLoad"  是事件，是做加载数据的时候执行的
       -->
       <van-list v-model="loading" :finished="finished" finished-text="没有更多了" @load="onLoad">
         <!-- van-cell单元格组件
                 特点：独占一行
                 用法非常灵活、复杂
                 title：单元格标题内容
         -->
         <van-cell v-for="item in list" :key="item" :title="item"/>
       </van-list>
     </div>
   </template>
   
   <script>
   export default {
     name: 'com-article',
     data () {
       return {
         // 瀑布流相关成员
         list: [], // 数据源
         loading: false, // 瀑布流是否加载处于动画效果
         finished: false // 瀑布流是否停止
       }
     },
     methods: {
       // 瀑布流上拉执行的动作
       onLoad () {
         // 异步更新数据
         // setTimeout 仅做示例，真实场景中一般为 ajax 请求
         setTimeout(() => {
           for (let i = 0; i < 10; i++) {
             this.list.push(this.list.length + 1)
           }
   
           // 加载状态结束
           this.loading = false
   
           // 数据全部加载完成
           if (this.list.length >= 40) {
             // 已经没有更多了，瀑布停止了
             this.finished = true
           }
         }, 1000)
       }
     }
   }
   </script>
   
   <style lang="less" scoped>
   // 给上拉列表区域设置样式
   .scroll-wrapper {
     height: 100%;
     // 瀑布流区域如果垂直方向内容过多，要呈现滚动条
     // 是瀑布实现的关键要素
     overflow-y: auto;
   }
   </style>
   
   ```

   

2. 在 home/index.vue 中把关于文章列表的瀑布三部分(template/script/style)内容统统都去除，同时导入、注册、使用独立的文章组件com-article.vue

   ```vue
   <van-tab title="推荐">
     <com-article></com-article>
   </van-tab>
   <van-tab title="数据库">
    <com-article></com-article>
   </van-tab>
   <van-tab title="后端">
     <com-article></com-article>
   </van-tab>
   ```
   
   ```js
   // 导入文章瀑布组件
   import ComArticle from './components/com-article.vue'
   export default {
     name: 'home-index',
     components: {
       // 注册
       ComArticle
     },
   ```



`效果`：

![1579753120118](img(online)/1579753120118.png)



注意：

​	每个（频道）标签都会拥有自己的文章瀑布



# 文章展示(下拉)

`目标`：

​	会使用van-pull-refresh组件，进行简单数据列表展示



应用到的组件库标签  文章列表（[PullRefresh 下拉刷新](https://youzan.github.io/vant/#/zh-CN/pull-refresh)），该组件具备“**下拉刷新**”功能

 下拉刷新时会触发 `refresh` 事件，在事件的回调函数中可以进行同步或异步操作，操作完成后将 `v-model` 设置为 `false`，表示加载完成 



`步骤`：

1. 在`home/components/com-article.vue`中模板中应用  pullrefresh  组件 
2. 组件实例中 为 上拉组件 创建data成员 和 methods 方法



home/components/com-article.vue代码部分：

```vue
<template>
  <!-- div的作用是给瀑布流区域设置“垂直滚动条”，使得可以进行上拉操作 -->
  <div class="scroll-wrapper">
    <!-- 下拉包围上拉 -->
    <!--
      v-model："isLoading" 设置下拉加载状态的
              // true：正在加载，自动修改为真，当发生"下拉"动作就变为true
              // false默认值，加载结束需要手动修改为false
      @refresh="onRefresh" 事件，当发生"下拉"动作是，该事件自动执行
                          // 该事件可以实现数据获取操作
    -->
    <van-pull-refresh v-model="isLoading" @refresh="onRefresh">
      <!-- 瀑布流加载效果实现
            瀑布流执行：
            1. 页面加载完毕，其会自动执行
              (内部会判断当前瀑布区域没有数据，当然要执行获取数据)
            2. 鼠标上拉动作，当滚动条到达"算法底部"，会执行
               算法底部：瀑布流认为要加载更多数据的位置
            v-model="loading"   表明是否是加载状态，默认为false
                                // 加载的时候，自动设置为true
                                // 加载完毕，请修改为false
                                // 是加载动画的体现
            :finished  表明瀑布停止了，没有更多数据不给加载了
                      鼠标上拉已经没有反应了
                      如果没有数据了，请设置finished为true
                      就表示都加载好了，显示没有更多了

            finished-text="没有更多了"  瀑布流停止，底部文字提示
            @load="onLoad"  是事件，是做加载数据的时候执行的
      -->
      <van-list v-model="loading" :finished="finished" finished-text="没有更多了" @load="onLoad">
        <!-- van-cell单元格组件
              特点：独占一行
              用法非常灵活、复杂
              title：单元格标题内容
        -->
        <van-cell v-for="item in list" :key="item" :title="item"/>
      </van-list>
    </van-pull-refresh>
  </div>
</template>

<script>
export default {
  name: 'com-article',
  data () {
    return {
      // 下拉成员
      isLoading: false, // 是否处于加载状态
      // 上拉相关成员
      list: [],
      loading: false,
      finished: false
    }
  },
  methods: {
    // 下拉执行的动作
    onRefresh () {
      // 设置1s延迟
      setTimeout(() => {
        this.onLoad() // 调用上拉获得数据
        this.isLoading = false // 下拉加载完成/结束加载动画
        this.$toast.success('刷新成功') // 成功提示
      }, 1000)
    },
    ……
```



`效果`：

![1579763814768](img(online)/1579763814768.png)





# 获取真实频道展示

> 真实频道数据在“后端mysql数据库”中存储着
> 因此需要通过axios获取回来展示
> 业务组件需要通过api操作axios
> 故现在要创建api函数
> 业务组件-->api--->axios
> api:url请求地址、method请求方式、请求参数
>
> 1. 创建api函数
> 文件：api/channel.js
> 函数名称：apiChannelList() 频道列表
> 2. home/index.vue做如下设置(5步走)
>     a. 导入api函数
>     b. 创建data成员，接收频道数据
>     c. 创建methods方法，获得频道数据
>     d. created调用methods方法，自动执行
>     e. 模板遍历展示

`目标`：

​	获取真实频道用于展示



`说明`：

频道在业务上可以理解为是文章的**分类**，每个频道下都有对应的文章信息

无论用户是否处于登录状态，都可以获取频道信息

- 未登录：获取默认频道列表供展示（移动端的**唯一标志**[华为、苹果]信息会被传递给服务器端用以识别）
- 已登录：获取当前用户拥有的频道进行展示（token数据被axios携带访问服务器端）



`步骤`：

1. 创建 api/channel.js 文件，封装获取频道的模块函数

   ```js
   // 导入axios对象
   import request from '@/utils/request.js'
   
   // 频道相关api函数配置文件
   
   /**
    * 获取用户的频道列表数据
    * 一般数据获取请求方式都是get
    * 当前函数不要传递参数(从【接口文档】可知)
    */
   export function apiChannelList () {
     // return：返回axios执行的结果
     return request({
       url: '/app/v1_0/user/channels',
       method: 'get'
     })
   }
   
   
   ```

   > 文档接口：【获取用户频道列表】

2. home/index.vue 中 导入 

   api函数
   
   设置data
   
   created
   
   methods成员
   
   v-for遍历展示获取到的频道
   
   ```vue
   <template>
     <div class="container">
       <!--
         van-tabs:标签页组件
           v-model设置默认激活项目 ，激活根据是项目的下标，从0开始
         van-tab: 标签页项目组件
           title：标签名称
           内容区域：标签对应内容
       -->
       <van-tabs v-model="activeChannelIndex">
         <!--对真实频道做遍历展示-->
         <van-tab :title="item.name" v-for="item in channelList" :key="item.id">
           <!-- 使用 -->
           <com-article></com-article>
         </van-tab>
       </van-tabs>
     </div>
   </template>
   
   <script>
   // 导入获得频道的api函数
   import { apiChannelList } from '@/api/channel.js'
   
   // 导入文章瀑布组件
   import ComArticle from './components/com-article.vue'
   export default {
     name: 'home-index',
     components: {
       // 注册
       ComArticle
     },
     data () {
       return {
         // 频道列表数据
         channelList: [],
         // 设置频道默认激活项目
         activeChannelIndex: 0
       }
     },
     created () {
       // 自动、第一时间 获取频道数据
       this.getChannelList()
     },
     methods: {
       // 获得频道列表数据
       async getChannelList () {
         // 通过api获得数据
         const result = await apiChannelList()
         // console.log(result)
         // data成员接收频道数据
         this.channelList = result.channels
       }
     }
   }
   </script>
   
   ```



`效果`：

![1579767510848](img(online)/1579767510848.png)

# 真实文章呈现

> 文章是列表数据
> 并且文章是根据频道做呈现的
> 每个频道下边都有n多的文章信息
> 结论：因此要通过频道作为条件获得文章信息
>
> 文章在mysql数据库里边
> 因此需要创建并应用api



`目标`：

​	根据频道获得相关的文章，并以列表形式展示



## 创建api函数：

创建 `api/article.js` 文件，封装模块函数，获得文章列表

> 接口文档：【频道新闻推荐_V1.1】,注意 版本为**v1_1**字眼，其他接口都是v1_0的

```js
// axios导入
import request from '@/utils/request.js'

// 文章相关api函数制作

/**
 * 根据频道获得文章列表信息
 * channel_id	是	频道ID
 * timestamp	是	时间戳整数 单位毫秒	时间戳，请求新的推荐数据传当前的时间戳，请求历史推荐传指定的时间戳
 *            用于数据【分页】(瀑布、下拉动作都是在获取“下一页”数据)
 *            timestamp=当前时间戳   获得第1页数据  数据返回来后有一个名称为 pre_timestamp的字段
 *            timestamp=上次数据的pre_timestamp  获得第2页数据  数据返回来后有一个名称为 pre_timestamp的字段
 *            timestamp=上次数据的pre_timestamp  获得第3页数据  数据返回来后有一个名称为 pre_timestamp的字段
 *            timestamp=上次数据的pre_timestamp  获得第4页数据  数据返回来后有一个名称为 pre_timestamp的字段
 *            ……
 *            如此反复，就可以不断获得"下一页"数据的效果了
 * with_top	  是	0或1	是否包含置顶，进入页面第一次请求时要包含置顶文章，1-包含置顶，0-不包含
 */
export function apiArticleList ({ channel_id, timestamp }) {
  return request({
    url: '/app/v1_1/articles',
    method: 'get',
    params: {
      channel_id,
      timestamp,
      with_top: 1
    }
  })
}

```





## 传递并接收频道id

> ​    关联的组件有两个
> ​    home/index.vue  呈现频道列表(父组件)
> ​    home/components/com-article.vue 呈现文章列表(子组件)
> ​    现在要进行"父-子组件传值"，把当前激活频道id传递给子组件，
> ​    使得可以获得对应的文章

获取文章列表，需要**频道id**条件，因此在父组件中要把当前频道id作为参数传递给子组件

父组件：home/index.vue，通过属性值方式传递频道id到子组件

```vue
      <van-tab :title="item.name" v-for="item in channelList" :key="item.id">
        <!-- 使用 ，把激活频道id当参数，传递给子组件-->
        <com-article :channelID="item.id"></com-article>
      </van-tab>
```



子组件：home/components/com-article.vue，要接收父组件传的频道id，具体通过props实现

```js
// 接收父组件传递过来的频道id信息
// 1. 简易方式接收
// props: ['channelID'],
// 2. 高级方式接收
props: {
  channelID: {
    // type:类型限制String Number Array, 类型不符合，就接收不到
    // required:true, 参数必须传递
    type: Number,
      required: true
  }
},
```

props接收父组件传递的信息更多使用支持： [https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E9%AA%8C%E8%AF%81](https://cn.vuejs.org/v2/guide/components-props.html#Prop-验证) 



## 获取文章实操

> ​    home/components/com-article.vue
> ​    a. 导入api
> ​    b. 创建data
> ​    c. methods方法
> ​    d. created
> ​    e. 遍历展示

在  `home/components/com-article.vue` 中做如下操作

1. 导入api函数

```js
// 导入获得文章的api函数
import { apiArticleList } from '@/api/article.js'
```



2. 声明data数据

```js
      articleList: [], // 文章列表信息
      // 通过ts声明时间戳条件，这样后期可以灵活发生变化
      ts: Date.now(), // 文章列表分页"时间戳"条件
```



3. 声明methods方法

```js
    // 获得文章列表信息
    async getArticleList () {
      // 调用api获得数据（参数:频道id、时间戳）
      const obj = {
        channel_id: this.channelID,
        timestamp: this.ts
      }
      const result = await apiArticleList(obj)
      // console.log(result)
      // data接收数据
      this.articleList = result.results
    },
```



4. 调用methods方法

   在created中调用

```js
created () {
  // 文章
  this.getArticleList()
},
```



5. 文章数据遍历

```vue
<!-- van-cell单元格组件
特点：独占一行
用法非常灵活、复杂
title：单元格标题内容
模板中应用超大整型数据，需要通过toString转换为"字符串"
-->
<!-- <van-cell v-for="item in list" :key="item" :title="item"/> -->
<van-cell
          v-for="item in articleList"
          :key="item.art_id.toString()"
          :title="item.title"/>
```



暂时 `home/components/com-article.vue` 的template和 script代码如下：

```vue
<template>
  <!-- div的作用是给瀑布流区域设置“垂直滚动条”，使得可以进行上拉操作 -->
  <div class="scroll-wrapper">
    <!-- 下拉包围上拉 -->
    <!--
      v-model："isLoading" 设置下拉加载状态的
              // true：正在加载，自动修改为真，当发生"下拉"动作就变为true
              // false默认值，加载结束需要手动修改为false
      @refresh="onRefresh" 事件，当发生"下拉"动作是，该事件自动执行
                          // 该事件可以实现数据获取操作
    -->
    <van-pull-refresh v-model="isLoading" @refresh="onRefresh">
      <!-- 瀑布流加载效果实现
            瀑布流执行：
            1. 页面加载完毕，其会自动执行
              (内部会判断当前瀑布区域没有数据，当然要执行获取数据)
            2. 鼠标上拉动作，当滚动条到达"算法底部"，会执行
               算法底部：瀑布流认为要加载更多数据的位置
            v-model="loading"   表明是否是加载状态，默认为false
                                // 加载的时候，自动设置为true
                                // 加载完毕，请修改为false
                                // 是加载动画的体现
            :finished  表明瀑布停止了，没有更多数据不给加载了
                      鼠标上拉已经没有反应了
                      如果没有数据了，请设置finished为true
                      就表示都加载好了，显示没有更多了

            finished-text="没有更多了"  瀑布流停止，底部文字提示
            @load="onLoad"  是事件，是做加载数据的时候执行的
      -->
      <van-list v-model="loading" :finished="finished" finished-text="没有更多了" @load="onLoad">
        <!-- van-cell单元格组件
              特点：独占一行
              用法非常灵活、复杂
              title：单元格标题内容
              模板中应用超大整型数据，需要通过toString转换为"字符串"
        -->
        <!-- <van-cell v-for="item in list" :key="item" :title="item"/> -->
        <van-cell
          v-for="item in articleList"
          :key="item.art_id.toString()"
          :title="item.title"/>

      </van-list>
    </van-pull-refresh>
  </div>
</template>

<script>
// 获得文章列表的api
import { apiArticleList } from '@/api/article.js'

export default {
  name: 'com-article',
  // 接收父组件传递过来的频道id信息
  // 1. 简易方式接收
  // props: ['channelID'],
  // 2. 高级方式接收
  props: {
    channelID: {
      // type:类型限制String Number Array, 类型不符合，就接收不到
      // required:true, 参数必须传递
      type: Number,
      required: true
    }
  },
  data () {
    return {
      articleList: [], // 文章列表信息
      // 通过ts声明时间戳条件，这样后期可以灵活发生变化
      ts: Date.now(), // 文章列表分页"时间戳"条件
      // 下拉成员
      isLoading: false, // 是否处于加载状态
      // 瀑布流相关成员
      list: [], // 数据源
      loading: false, // 瀑布流是否加载处于动画效果
      finished: false // 瀑布流是否停止
    }
  },
  created () {
    // 获得真实文章列表数据
    this.getArticleList()
  },
  methods: {
    // 获得文章列表信息
    async getArticleList () {
      // 调用api获得数据（参数:频道id、时间戳）
      const obj = {
        channel_id: this.channelID,
        timestamp: this.ts
      }
      const result = await apiArticleList(obj)
      // console.log(result)
      // data接收数据
      this.articleList = result.results
    },
    // 下拉执行的动作
    onRefresh () {
      // 设置1s延迟
      setTimeout(() => {
        this.onLoad() // 调用上拉获得数据
        this.isLoading = false // 下拉加载完成/结束加载动画
        this.$toast.success('刷新成功') // 成功提示
      }, 1000)
    },

    // 瀑布流上拉执行的动作
    onLoad () {
      // 异步更新数据
      // setTimeout 仅做示例，真实场景中一般为 ajax 请求
      setTimeout(() => {
        for (let i = 0; i < 10; i++) {
          this.list.push(this.list.length + 1)
        }

        // 加载状态结束
        this.loading = false

        // 数据全部加载完成
        if (this.list.length >= 40) {
          // 已经没有更多了，瀑布停止了
          this.finished = true
        }
      }, 1000)
    }
  }
}
</script>
```





`暂时效果`：

![1579770607492](img(online)/1579770607492.png)



说明：

![1579770556052](img(online)/1579770556052.png)

根据频道获得文章列表信息需要3个参数条件，分别说明如下：

1. channel_id：文章是挂靠在频道下边的，所有的文章都需要根据频道进行获取，已经通过父组件获得并应用

2. timestamp：本身是时间戳的意思，在当前应用处，该字段用作**分页效果**实现(每页固定是10条记录)

   ​	第一次请求，把**当前时间戳**传递给服务器端，表示获取<font color=red>第1页</font>数据，同时服务器端会返回一个名称为pre_timestamp的字段，也是时间戳的意思

   ​	第二次请求，把上一次请求回来的**pre_timestamp**回传给服务器，此时服务器会智能识别出来，这是客户端向我索取<font color=red>第2页</font>数据信息，信息回来的时候，也会携带pre_timestamp字段 时间戳信息

   ​	第三次请求，再把上一次请求回来的**pre_timestamp**回传给服务器，此时服务器会智能识别出来，这是客户端向我索取<font color=red>第3页</font>数据信息，信息回来的时候，也会携带pre_timestamp字段 时间戳信息

   ​	……

   ​	如此反复，每次请求都把上次回来的pre_timestamp字段回传给服务端，就达到获取不同页码数据的效果了

3. with_top：服务器端没有实现该功能，我们直接设置为1即可





## 上拉加载与文章结合

`目标`：

​	把  上拉功能 和 真实文章  结合在一起



`步骤`：

1. 在  home/components/com-article.vue  中，对获取文章的methods方法做调整如下：

   (直接return返回结果)

   ```js
   // 获得文章列表信息
   // async修饰的函数，这个函数如果有return返回信息，
   // 信息类型是Promise对象
   
   async getArticleList () {
     // 调用api获得数据（参数:频道id、时间戳）
     const obj = {
       channel_id: this.channelID,
       timestamp: this.ts
     }
     const result = await apiArticleList(obj)
     // console.log(result)
     // data接收数据
     // 升级：不要把数据给与data成员，要在瀑布里边发生给与动作
     //       在这里边请return返回，用瀑布接收使用
     return result
     // this.articleList = result.results
   },
   ```
   
> articleList对新文章数据由之前的直接赋值，变为现在的push追加
>
> return 返回文章结果
>
> 注意：函数有async修饰，内部有return返回，这这个结果是Promise对象

2. 瀑布上拉载入methods方法调整为如下：

   ```js
   // 瀑布流上拉执行的动作
   async onLoad () {
     // 瀑布 与 真实文章 结合
     // 1. 获得真实文章数据
     const articles = await this.getArticleList()
     // articles:{results:文章列表，pre_timestamp:分页时间戳}
     // console.log(articles)
     // 2. 对数据做处理
     if (articles.results.length > 0) {
       // 有获得数据
       // data接收数据，要设置"追加"，不要直接赋值
       // 直接赋值会使得瀑布的数据区域填充不满，会造成瀑布不断加载效果
       // this.articleList = articles.results
       // articles.results:[{id,title,xx},{id,title,xx},{id,title,}……]
       this.articleList.push(...articles.results)
       // ... 展开运算符，是要把[]数组标志给去除，使得内部各个小元素暴露出来，进而被push追加使用
       // this.articleList.push({id,title,xx},{id,title,xx},{id,title,}……)
    // 更新时间戳，方便获取"下一页"数据
       this.ts = articles.pre_timestamp
     } else {
       // 没有获得到数据，要停止瀑布流
       this.finished = true
     }
   
     // 3. 停止瀑布加载动画
     this.loading = false
   }
   ```
   
   > 配置 async、await接收getArticleList()返回结果
   >
   > 调用getArticleList()获得文章列表
   >
   > 关闭加载状态
   >
   > 判断pre_timestamp如果为假，即表示已经没有文章可供获取，要停止上拉载入功能
   >
   > pre_timestamp返回为0，即表示没有文章可供获取了



`效果`：

![1579773093176](img(online)/1579773093176.png)



## 延迟加载

`目标`：

加载时,给予一定的**延迟**效果,提高用户体验,让数据的加载不要太快，给与一定缓存



`代码`：

`main.js`创建延迟器

```js
// 设置一个全局延迟器，是Vue的继承成员，名称为$sleep，就是"自定义"的
// 使得组件可以调用： this.$sleep() ,开始要做延迟执行
// time形参，表示等待时间，毫秒
Vue.prototype.$sleep = (time) => {
  // Promise对象返回：应用端可以介入await，这样异步过程变为同步过程，可以保证当前代码没有执行完毕，
  // 后续代码不要执行
  return new Promise((resolve) => {
    // setTimeout设置具体延迟
    setTimeout(() => {
      // resolve()是空执行，打酱油的
      resolve()
    }, time)
  })
}
```

> $sleep中有Promise的好处是，可以通过  async / await 控制异步请求为同步请求 ， setTimeout可以设置执行时间



`home/components/com-article.vue`->methods->onLoad 中

```js
// 瀑布流上拉执行的动作
async onLoad () {
  // 每次执行给延迟0.8秒
  await this.$sleep(800)
```

`效果`：

![1580362752760](img(online)/1580362752760.png)

`注意`：

​	写普通的window.setTimeout()也可以设置延迟器效果，但是这个代码复杂，开发、维护不方便



## Promise回顾

then/catch

async/await

try/catch

```js
// 通过nodejs方式，对3个文件内容进行读取
const fs = require('fs')

// 1. 文件读取，结果没有固定顺序
// 下述文件读取都是“异步”方式进行的，3个文件同时进行读取
// 由于电脑资源分配不均匀，导致结果的产生并没有固定顺序
// fs对文件进行读取
// fs.readFile('./files/1.txt','utf8',function(err,data){
//   if(err){return console.log('文件读取有错误：'+err)}
//   // 文件读取正常，data是从文件中获取到内容
//   console.log(data)
// })
// fs.readFile('./files/2.txt','utf8',function(err,data){
//   if(err){return console.log('文件读取有错误：'+err)}
//   // 文件读取正常，data是从文件中获取到内容
//   console.log(data)
// })
// fs.readFile('./files/3.txt','utf8',function(err,data){
//   if(err){return console.log('文件读取有错误：'+err)}
//   // 文件读取正常，data是从文件中获取到内容
//   console.log(data)
// })

// 2. 要求，各个文件结果按照123的顺序产生
//    前者结果产生了，再触发获取后者
//    经过设计，代码如下，代码是深层嵌套，形成"回调地狱"，代码不好
//    开发、维护非常麻烦，凡是嵌套的代码开发维护都麻烦
// 读取1文件
// fs.readFile('./files/1.txt','utf8',function(err,data){
//   if(err){return console.log('文件读取有错误：'+err)}
//   // 文件读取正常，data是从文件中获取到内容
//   console.log(data)
//   // 获取后者，读取2文件
//   fs.readFile('./files/2.txt','utf8',function(err,data){
//     if(err){return console.log('文件读取有错误：'+err)}
//     // 文件读取正常，data是从文件中获取到内容
//     console.log(data)
//     // 获得后者，读取3文件
//     fs.readFile('./files/3.txt','utf8',function(err,data){
//       if(err){return console.log('文件读取有错误：'+err)}
//       // 文件读取正常，data是从文件中获取到内容
//       console.log(data)
//     })
//   })
// })

// 3. Promise介入
//    其可以使得代码按照顺序执行，并且没有回调地狱
//    代码的开发比较方便、可读性非常好
//    Promise介入必须使用函数封装
//    filename:被读取的文件名称
function getContent(filename){
  // 把生成好的Promise对象给返回出去
  // resolve和reject是两个形参，它们都是函数
  // resolve:异步调用"成功"的回调函数
  // reject:异步调用"失败"的回调函数

  // Promise对象内部不要体现业务代码，例如console.log()
  // 业务的数据要通过resolve和reject给封装起来
  return new Promise(function(resolve,reject){
    // 设计异步执行过程
    fs.readFile(filename,'utf8',function(err,data){
      if(err){return reject('文件读取有错误：'+err)}
      // 文件读取正常，data是从文件中获取到内容
      resolve(data)
    })
  })
}

// B. then/catch按照"顺序"读取文件内容
// then(回调函数参数)
// catch(回调函数参数)
// then()方法执行完毕会返回一个空的Promise对象，
// 如果then内部return一个实体Promise对象，则其会覆盖空的Promise对象
// 在后边因此还可以连贯调用catch()
// 如下代码虽然也有嵌套，但是有"节制"，不会无限嵌套
/*
getContent('./files/1.txt')
  .then(function(result){
    // 读取1文件内容
    console.log(result)
    // 1文件内容输出好了，去读取2文件内容，getContent()函数要返回Promise对象
    // 这个Promise对象就直接被then方法接收到了
    return getContent('./files/2.txt')
  })
  .then(function(result){
    // 读取2文件内容
    console.log(result)
    // 同理，2文件内容输出好了，去读取3文件内容，，getContent()函数要返回Promise对象
    return getContent('./files/3.txt')
  })
  .then(function(result){
    // 读取3文件内容
    console.log(result)
  })
  .catch(function(error){
    console.log(error)
  })
  */
  // 最后的catch会一并获取上述各个语句的错误信息
  // 1错误，2、3停止执行
  // 2错误，1执行  3停止
  // 3错误，1/2执行




// A. 如下方式读取文件没有固定顺序
// const p1 = getContent('./files/1.txt')
// const p2 = getContent('./files/2.txt')
// const p3 = getContent('./files/3.txt')
// // console.log(p1) // Promise对象
// // 进一步获得文件读取的“成功信息resolve的实参”或“失败信息reject的实参”
// // p1
// //   .then(function(result){result 与 resolve的实参data对应})
// //   .catch(function(error){error  与 reject的实参对应})
// p1
//   .then(function(result){ console.log(result) })
//   .catch(function(error){ console.log(error) })
// p2
//   .then(function(result){console.log(result)})
//   .catch(function(error){console.log(error)})
// p3
//   .then(function(result){console.log(result)})
//   .catch(function(error){console.log(error)})

// 4. 更高级玩法来了
/*
//    async和await要介入了，其是ES7标准技术
async function getThreeFile(){
  // getContent()函数会返回Promise对象
  // 需要3个文件的结果按照“顺序”输出出来
  // await对getContent()的Promise对象结果进行修饰
  // 导致其会获得到 resolve的实参数据，就不用调用then方法
  
  // await英文单词翻译：等待的意思
  // 特点：当前await语句没有执行完毕，后续代码不会执行
  //       因此可以保证异步程序变为同步程序，有着顺序执行的特性
  console.log(await getContent('./files/1.txt'))
  console.log(await getContent('./files/2.txt'))
  console.log(await getContent('./files/3.txt'))
}
getThreeFile()
*/
// async特点：
// 1. 可以对全部的函数进行修饰，函数内部如果有return返回信息，这个信息是Promise对象
// 2. async必须要放置到await外边最近的function前边去
// 例如：
// function getInfo(){
//   abc(async function(){
//       const result = await axios()
//   })
// }
// await特点：
// 1. 必须与async结合使用
// 2. await可以对全部类型数据进行修饰，字符串、整型、数组等都可以修饰，但是修饰Promise对象更有意义


// 5. try/catch处理异常
//    async和await介入只是简化then()方法调用
//    (本身没有集成catch方法)
//    如果要考虑"异常"情况，可以结合try/catch一并做应用
//    try、catch是es5标准语法
async function getThreeFile(){
  try{
    // 放置有可能产生错误的代码
    const rst = await getContent('./files/1.txt')
    console.log(rst)
  }catch(err){
    // 对错误进行步骤
    // err就是 reject的实参数据
    console.log(err) 
  }
  // 只要try/catch内部没有return语句，如下的1234始终输出
  console.log(1234)
}
getThreeFile()
// 注意：
// try/catch不是每个Promise对象都需要设置的
// 如果在"一切都ok"的情况下，不会产生异常，就可以不用设置
// 例如：
// 1. 管理员登录系统，异步方式校验账号，"要"设置try/catch
// 2. 项目内部获得“频道数据”，只要服务器不崩溃都可以正常获得数据，就“不用”设置try/catch

// try/catch特点：
// 1. try catch 是不是就是为了防止错误出现使得代码运行不下去?
//    使得代码"完整"运行


```





## 文章列表布局

>     每个文章项目要展示的内容有
>     标题、封面图片、作者、评论数目、发布时间
>     以上内容呈现布局效果
>     这个布局大方面使用了van-cell单元格组件
>     
>     title: 设置单元格做上角的标题信息
>     value: 设置单元格右侧内容的
>     label: 设置单元格下方描述信息
>     icon: 给title配置左侧图标
>     is-link: 给单元格有的配置箭头图标
>     to: 配置路由地址
>     
>     <van-cell title="单元格" value="内容" label="描述信息" />
>     如上"单元格"通过各个属性体现不同位置内容,有一定局限性
>     如果需要给单元格相关位置自定义复杂内容，可以通过"命名插槽"实现
>     例如对title内容定制
>     <van-cell value="内容" label="描述信息">
>         <template slot="title">
>             <p>111</p>
>             <p>222</p>
>         </template>
>     </van-cell>
>     关于命名插槽slot="title",多个位置都可以定位
>     default	自定义右侧内容(类似value)
>     title	自定义左侧标题
>     label	自定义标题下方描述
>     icon	自定义左侧图标
>     right-icon	自定义
>     例如，我们文章列表项目的描述信息(图片、作者、评论、时间)
>     就可以进行slot="label"的定制操作
>
>
> ​    
>     每个文章还会显示封面图片
>     文章图片分类：没有、1个、3个
>     要使用固定的"vant宫格组件"才会显示要求的效果
>     icon： 宫格图标
>     text： 提示文字
>     :column-num="3" 规定，一行就显示3列，默认值为4列
>     :gutter="10" 配置宫格间距
>     :border="false" 设置宫格没有边框
>     <van-grid :column-num="3"  :gutter="10" :border="false">
>       <van-grid-item icon="photo-o" text="文字" >
>     ​    自定义宫格显示内容，会覆盖text、icon
>     ​    <van-image src="https://img.yzcdn.cn/vant/apple-1.jpg" />
>       </van-grid-item>
>       <van-grid-item icon="photo-o" text="文字" />
>       <van-grid-item icon="photo-o" text="文字" />
>       <van-grid-item icon="photo-o" text="文字" />
>     </van-grid>

`目标`：

​	将文章的相关内容进行布局渲染



`知识点`：

van-cell单元格组件

对cell表格指定位置进行填充

官网详情：https://youzan.github.io/vant/#/zh-CN/cell

```html
<van-cell>
  <!--表示对单元格的指定位置进行内容填充，除了label还可以使用default、title、icon、right-icon等-->
  <template slot="label"></template>
</van-cell>
```

> default	自定义右侧内容
> title	自定义左侧标题
> label	自定义标题下方描述内容区域
> icon	自定义左侧图标
> right-icon	自定义右侧按钮，默认为arrow



宫格组件：

可以在水平方向上把页面分隔成等宽度的区块，用于展示内容或进行页面导航 

官网详情： https://youzan.github.io/vant/#/zh-CN/grid#yin-ru 

```html
<van-grid :border="false" :column-num="3">
  <van-grid-item >内容</van-grid-item>
  <van-grid-item >内容</van-grid-item>
  <van-grid-item >内容</van-grid-item>
</van-grid>
```

> border：是否有边框
>
> column-num：每一行格子的数量
>
> van-grid-item：格子单元



van-image ： 增强版的 img 标签，提供多种图片填充模式，支持图片懒加载、加载中提示、加载失败提示 

官网详情： https://youzan.github.io/vant/#/zh-CN/image 

```html
<van-image
  width="85" // 宽度
  height="85" // 高度
  src="https://img.yzcdn.cn/vant/cat.jpeg" // 图片路径名
/>
```



`实施`

对cell单元格内容进行填充，要填充的内容有 宫格、图片、作者、评论、时间

`home/components/com-article.vue->template`

```html
<!-- van-cell单元格组件
特点：独占一行
用法非常灵活、复杂
title：单元格标题内容
模板中应用超大整型数据，需要通过toString转换为"字符串"
-->
<!-- <van-cell v-for="item in list" :key="item" :title="item"/> -->
<van-cell v-for="item in articleList" :key="item.art_id.toString()" :title="item.title">
  <!-- 通过命名插槽方式体现单元格下方描述信息 -->
  <template slot="label">
    <!-- 新闻封面图片也是通过label描述位置体现
:column-num 根据type的值决定显示的列数
v-if="item.cover.type>0" 要求type>0才体现宫格
:border="false" 宫格没有边框
-->
    <van-grid
              :column-num="item.cover.type"
              :gutter="10"
              :border="false"
              v-if="item.cover.type>0"
              >
      <!-- 封面图片类型：没有type=0、 1个type=1、 3个type=3 -->
      <!-- v-for可以对数字做遍历 -->
      <!-- v-for="xx in 3" //xx: 1、2、3  -->
      <van-grid-item v-for="item2 in item.cover.type" :key="item2">
        <!-- van-image是表现图片的组件，图片下标是从0开始，自然item2-1操作 -->
        <van-image  width="85" height="85" :src="item.cover.images[item2-1]"/>
      </van-grid-item>
    </van-grid>
    <p>
      <span>作者:{{item.aut_name}}</span>
      &nbsp;
      <span>评论 :{{item.comm_count}}</span>
      &nbsp;
      <span>时间:{{item.pubdate}}</span>
      &nbsp;
    </p>
  </template>
</van-cell>
```

`效果`：

![1580364764853](img(online)/1580364764853.png)

`注意`: 

1. 个别图片请求失败,报错403->代表无权限访问，是接口问题，可以不处理
2. 每条文章数据中的cover.type=1、3表示有图片,0表示没图片
3. 这里利用slot命名插槽自定义单元格描述内容label
4. 相对时间之后会进行处理



## 图片懒加载

> 项目文章一页数据返回回来，每个文章都或多或少有封面图片内容
> 由于手机设备屏幕比较小，一页数据10条内容，但是只显示前5条
> 只看到前5条文章的图片，后5条文章的图片并没有出现，用户也不拖动
> 滚动条往下看，为了节省服务器资源，我们要做“图片懒加载”功能
> 在屏幕视野中出现的图片就加载执行，没有出现的图片就不加载
> 用户看多少就加载多少，这样节省资源
>
> vant已经把懒加载给封装好了，直接引入使用即可

`目标`：

​	给文章图片设置懒加载，使得浏览器视野中出现的图片才加载，没有出现的滞后载入



说明链接： https://blog.csdn.net/w1418899532/article/details/90515969 

懒加载可以降低不必要的服务器资源的开销

视野中即将出现的图片就获取载入，没有显示的图片就不要获取，可以节省服务器资源



`步骤`：

1. main.js中导入入、安装Vant中的Lazyload指令

   ```js
   // 导入,Vant是默认的成员导入，Lazyload是按需成员导入
   // eslint要求：同一个功能包的不同模块对象要使用一个语句到导入进来
   // 默认、按需同时导入 import XXX,{YYY,KKK,MMM} from '模块'
   // 注意：默认在前，按需在后
   import Vant, { Lazyload } from 'vant'
   ……
   // 对Lazyload指令做注册
   Vue.use(Lazyload)
   ```

   

2. 为van-image设置lazy-load指令属性

`代码`：

`home/components/com-article.vue`

```html
<!-- lazy-load设置图片懒加载，是一个自定义指令 -->
<van-image width="90" height="90" :src="item2" lazy-load/>
```



`注意`：

可以通过浏览器调试工具firebug筛选请求类型并查看



## 时间处理

> 文章列表的时间信息要做处理，使得显示的更友好
> 根据企业级项目提示，我们的时间要显示为
> 刚刚、n分钟之前、n小时之前、n天之前、n月之前、年月日时分秒
> 理论上：要手动制作filter过滤器
> 实际上：团队实战的【过滤器】拿过来用即可

`目标`：

​	把后台返回的时间处理成相对时间、格式化

`步骤`：

1. 创建 utils/filters.js 文件，并把**团队实战**项目的过滤器文件( src/filters/index.js )内容全部复制过来

2. 把过滤器函数formatTime函数的第一个语句 注释掉 // time = +time * 1000

   ```js
   export function formatTime (time, option) {
     // time = +time * 1000
   ```

3. 在main.js中对各个过滤器进行注册

   ```js
   import * as filters from '@/utils/filters' // 过滤器
   
   // 注册全局过滤器
   Object.keys(filters).forEach(item => {
     Vue.filter(item, filters[item])
   })
   
   ```

4. `home/components/com-article.vue`  -> template 使用过滤器

   ```html
   <span>时间:{{item2.pubdate | formatTime}}</span>
   ```



`效果`：

![1580367699665](img(online)/1580367699665.png)



# 组件应用v-model(扩展)【2000】

> v-model特点：
> 1. 针对value属性进行绑定
> 2. 绑定的内容必须是“data成员属性”信息，
>  不能是表达式,例如v-model="num+100" 错误
> 3. v-model针对表单域标签进行绑定，输入框、下拉列表、单选按钮等等
> 4. v-model在组件身上也可以使用
> 5. v-model简易原理，其就是 【:value属性 + @input事件】 的结合
>
> 讲解步骤：
> 1. 创建一个vuecli空项目
>
> 2. v-model简易原理的体现
>
> 3. v-model在【组件】上的使用
>  有的时候一个普通的表单域有做v-model绑定
>  然后这个v-model的值还不是自己组件能够决定的
>  相反是通过父组件来影响赋值的
>  形式上看：父、子组件应用:
>  A. 父组件 导入、注册、使用 子组件，传递v-model的信息
>  B. 子组件普通表单域应用v-model，v-model要接收应用父组件传递过来的信息
>
>  具体学习：
>     1. 创建【子】组件 components/com-input.vue
>      在这个子组件里边有input框，还有v-model="value"
>      props:['value']  接收父组件设置的v-model信息
>
>     2. App.vue充当【父】组件
>      对com-input.vue 做 导入、注册、使用
>      子组件标签要使用v-model
>      <com-input v-model="username">  username="mary"
>    
>     3. 子组件 对v-model数据做修改，要影响到父组件的username
>    
>      ```
>      <p>value+oninput：<input type="text" 
>      									:value="city" @input="city=$event.target.value"></p>
>      <p>value+oninput：<input type="text" 
>      									:value="city" @input="mod"></p>
>      ```
>
>
> ​     
> ​     
>    ​    methods: {
>    ​      mod (evt) {
>    ​        this.city = evt.target.value
>    ​      }
>    ​    }
>      上述两个input框都在模拟v-model
>      结论：@ input事件一旦发生执行，就要把当前“输入框输入的信息”给获得到，并赋予给city
>    ​        这样v-model效果就出现了
>    ​        换一个说法，@ input事件发生，就要把“目标信息”赋予给v-model的属性值
>    ​        目标信息===输入框输入的信息===当前事件感知到的信息
>

v-model指令的使用【非常重要、实用的技术】
1. 表单域标签中可以使用
2. 在组件标签中也可以使用(该组件一定要包含表单域标签)

v-model应用在组件中
## 创建vuecli项目

1. 执行指令：vue create  01-pro

   自定义依赖包，增加CSS Pre-processors选项即可(路由、vuex不用安装)

![1583634242831](img(online)/1583634242831.png)

2. 删除components无用的helloworld.vue组件

3. App.vue组件初始化

   ```vue
   <template>
       <div>
         <h2>App根组件(v-model继续学习)</h2>
       </div>
   </template>
   
   <script>
   export default {
     name: 'app'
   }
   </script>
   
   <style lang="less" scoped>
   </style>
   
   ```

   

4. vue.config.js文件简单配置

   ```js
   module.exports = {
     lintOnSave: false,
     devServer: {
       open: true
     }
   }
   
   ```

   

5. 启动项目 npm run serve

   ![1583634491922](img(online)/1583634491922.png)

## 普通表单域标签的v-model应用（回顾）

普通表单域标签input里边可以使用v-model

同时v-model简易原理是  value  +  oninput  的结合体现

```vue
<template>
    <div>
      <h2>App根组件(v-model继续学习)</h2>
      <!-- v-model基本使用 -->
      <p> {{city}} </p>
      <p> v-model原生：<input type="text" v-model="city" /> </p>
      <!-- 事件驱动既可以绑定methods方法(例如mod)，也可以设置简单语句
            元素行内事件内部可以通过关键字 $event 表达"事件对象"，$event是vue语法
      -->
      <p>value+oninput：<input type="text" :value="city" @input="city=$event.target.value"></p>

      <!-- v-model简易原理：:value + @input 的结合，模仿v-model效果
        oninput事件，输入框有内容输入的时候会感知并执行
        mod事件驱动没有()括号，使得方法的第一个参数evt就代表事件对象
      -->
      <p>value+oninput：<input type="text" :value="city" @input="mod"></p>
    </div>
</template>

<script>
export default {
  name: 'app',
  data () {
    return {
      city: '北京'
    }
  },
  methods: {
    mod (evt) {
      // evt:事件对象，名字可以自定义
      // console.log(evt) // InputEvent
      // console.log(evt.target) // 当前input输入框的dom对象
      // console.log(evt.target.value) // 获得 当前input输入框的dom对象 的value属性信息
      //                                  就是用户目前已经输入的内容
      // 把用户输入的信息赋予给city，实现双向绑定效果
      this.city = evt.target.value
    }
  }
}
</script>

<style lang="less" scoped>
</style>

```

结论：v-model是value属性 和 oninput事件的结合



## 组件标签应用v-model（扩展）

目标：

​	父子组件嵌套，父组件设置v-model，会影响到子组件的v-model结果(要通过value+oninput结合体现)

​	子组件修改表单域信息，也会影响给父组件



父组件：

```vue
<com-input v-model="username"></com-input>
```

> 本质：\<com-input :value="username"  @input="username=当前事件感知到的信息"\>\</com-input\>

子组件：

```vue
props:['value']
<input type="text"
       :value="value"
       @input="$emit('input',$event.target.value)"
       />
// :value+@input 就是v-model的体现，但是数据会反馈给父组件
```



通过应用得出结论：

​    父组件标签应用v-model，本质就是value属性 和 @input事件的结合
​    子组件通过props接收value值，应用value，就是在使用父组件v-model的信息

​	$emit('input',xxx) 调用input事件，把变化后的信息同步更新给父组件的成员



应用代码：

父组件App.vue：

```vue
<template>
    <div>
      <h2>App根组件(v-model组件标签应用)</h2>
      <p>当前App父组件的username:{{username}}</p>
<!-- 使用
    【子组件标签要使用v-model】
    实际上要把v-model的信息传递给内部的input框的v-model去使用

    通过之前的学习可知：v-model= :value+@input
    <com-input :value="username" @input="username=$event.target.value"></com-input>
    形式上就是给子组件传递名称为【value的属性】信息，给子组件传值
    同时还给子组件创建了一个名称为【input的事件】
-->
      <com-input v-model="username"></com-input>

      <!--
        子组件传值，可以是多种形式，普通属性值和对象都可以
        <com-input v-model="username" city="beijing" :obj="{name:'black',leg:4}"></com-input>
      -->
<!-- 父组件给子组件传递数据信息，要给子组件标签设置"属性值"传递
属性：value
值：username
子组件接收：props:['value']
<com-input :value="username" city="beijing" @input="username=$event.target.value"></com-input>
-->
    </div>
</template>

<script>
// 导入
import ComInput from './components/com-input.vue'
export default {
  name: 'app',
  components: {
    // 注册，简易成员赋值
    ComInput
  },
  data () {
    return {
      username: 'mary'
    }
  }
}
</script>

<style lang="less" scoped>
</style>

```

子组件(components/com-article.vue)：

```vue
<template>
    <div>
      <p>
        用户名：
        <input type="text"
          :value="value"
          @input="$emit('input',$event.target.value)"
        />
      </p>
    </div>
</template>

<script>
export default {
  name: 'com-input',
  // 接收父组件传递过来的信息，名称为value
  // props: ['value', 'city', 'obj']
  props: ['value'],
  methods: {
    // 修改当前输入框v-model的内容
    xiu (evt) {
      // 要把修改后的数据信息传递给父组件的username
      // 子组件要调用父组件传递过来的"input事件"
      // evt.target.value代表输入框即时输入的信息
      // input事件一旦发生，就要感知该事件的信息，并对username进行修改
      this.$emit('input', evt.target.value)
    }
  }
}
</script>

<style lang="less" scoped>
</style>

```

效果：

![1583639621133](img(online)/1583639621133.png)

组件上使用v-model，官网详情：

 [https://cn.vuejs.org/v2/guide/components-custom-events.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model](https://cn.vuejs.org/v2/guide/components-custom-events.html#自定义组件的-v-model) 



注意：

​	input type="text"输入框v-model=====：value+@input

​	input type="checkbox" 复选框: v-model======：checked+@change

​	不同表单域标签对v-model的拆解不同



最终结论：

​	子组件标签使用v-model

​	子组件通过props：value接收v-model的数据信息，子组件表单域 要设置 :value+@input，不要使用v-model

​	子组件自己表单域的数据变化了，可以通过**\$emit**调用**input事件**，进而把变化后的信息传递给**父组件**的v-model成员



# 文章不感兴趣



## 叉号图标

在 `home/components/com-article.vue` 里边设置  **叉号X按钮** ，使得单击后可以展示更多操作效果

```vue
<p>
              <!--给 van-cell  的右侧设置叉号按钮
                van-icon:图标组件
							 name="close"代表叉号
              -->
              <van-icon name="close" style="float:right;"/>
              <span>作者:{{item.aut_name}}</span>
              &nbsp;
              <span>评论 :{{item.comm_count}}</span>
              &nbsp;
              <span>时间:{{item.pubdate | formatTime}}</span>
              &nbsp;
            </p>
          </template>
        </van-cell>
      </van-list>
    </van-pull-refresh>

```

`效果`：

![1583586726699](img(online)/1583586726699.png)



## 弹出框

单击叉号按钮显示**对话框**，在对话框里边呈现要操作的明细项目



对话框组件

官网详情： https://youzan.github.io/vant/#/zh-CN/dialog 

```html
<!-- 暂时表现弹出框效果
  v-model：设置弹出框是否显示 true显示、false不显示
  title：弹出框标题，可以不设置
  show-cancel-button：显示取消按钮
  :showConfirmButton="false" 不要显示取消按钮，false是boolean值
  showConfirmButton="false" false是字符串

  closeOnClickOverlay 是否在点击遮罩层后关闭弹窗,不要绑定内容，就是true被绑定
  :closeOnClickOverlay="true"
-->
<van-dialog v-model="show" :showConfirmButton="false" closeOnClickOverlay>
  <img src="https://img.yzcdn.cn/vant/apple-3.jpg" width="230" height="130" />
</van-dialog>
```



## 显示与隐藏

> 单击叉号  弹出框 展示
> 单击旁出  弹出框 消失
> 文章不感兴趣操作较为“复杂”，为了提高开发、维护效率
> 要把"弹出框"的组件内容放到一个"独立组件"中做维护
> 独立组件名称：home/components/com-moreaction.vue【子组件】
> 这个组件要被  home/components/com-article.vue【父组件】所  导入、注册、使用
>
> (文章不感兴趣、举报通常为文章的  “更多操作”，英文 moreaction)

现在要实现不感兴趣对话框的  **显示**  与  **隐藏**  功能

`目标`：

1. 在每条文章内容旁处有x号按钮，点击x，打开对话框
2. 点击对话框外边实现关闭效果



说明：

​	有的用户对某类文章不感兴趣，模拟实现取消订阅效果



`步骤`：

1. 创建`home/components/com-moreaction.vue`文件，设置弹框内容

   因为 不感兴趣 操作相对**比较复杂**，所以要把对话框通过独立组件给封装起来，这样开发维护比较方便，所以要做如下操作

   ```vue
   <template>
     <div>
       <!-- 暂时表现弹出框效果
     v-model：设置弹出框是否显示 true显示、false不显示
     title：弹出框标题，可以不设置
     show-cancel-button：显示取消按钮
     :showConfirmButton="false" 不要显示取消按钮，false是boolean值
     showConfirmButton="false" false是字符串
   
     closeOnClickOverlay 是否在点击遮罩层后关闭弹窗,不要绑定内容，就是true被绑定
     :closeOnClickOverlay="true"
       -->
       <van-dialog
         :value="value"
         @input="$emit('input',$event)"
         :showConfirmButton="false" closeOnClickOverlay>
         <img src="https://img.yzcdn.cn/vant/apple-3.jpg" width="230" height="130">
       </van-dialog>
         <!-- :value+@input 是 v-model的体现
           @input="$emit('input')" $emit调用input事件，把感知到的信息
           传递给事件对应的v-model成员里边，即父组件的showDialog
           当前组件，鼠标单击对话框旁处，就可以使得value属性值为false
           这个false信息要传递给showDialog，这可以使得后续该弹出框不断被展示出来
   
           理论上代码应该为：$emit('input',$event.target.value)
           实际上不要设置$event.target.value，设置到不对，因为
           van-dialog是组件，不是普通表单域，$event.target.value不能表达出来当前组件的value属性信息
           @input="$emit('input',$event)" 在van-dialog内部会被"封装"为
           $emit('input',$event.target.value)
   
           组件标签都是：@input="$emit('input',$event)"
           普通表单域：$emit('input',$event.target.value)
         -->
     </div>
   </template>
   
   <script>
   export default {
     name: 'more-action',
     props: ['value'],
     data () {
       return {
         show: false
       }
     }
   }
   </script>
   
   <style lang="less" scoped>
   </style>
   
   ```




2. 在 home/components/com-article.vue 里边做如下操作

   > com-moreaction.vue引入使用
   >
   > 设置叉号X按钮 和 点击事件
   >
   > 控制开关showDialog
   >
   > methods方法，实现弹出框弹出
   >
   > data成员，弹出框是否弹出标志
   >
   
   ```vue
   						<p>
                 <!--给 van-cell  的右侧设置叉号按钮
                   van-icon:图标组件
                   name：图标样式
                 -->
                 <van-icon name="close" style="float:right;" @click="displayDialog()"/>
                 <span>作者:{{item.aut_name}}</span>
                 &nbsp;
                 <span>评论 :{{item.comm_count}}</span>
                 &nbsp;
                 <span>时间:{{item.pubdate | formatTime}}</span>
                 &nbsp;
               </p>
             </template>
           </van-cell>
         </van-list>
       </van-pull-refresh>
   
       <!-- 文章更多操作弹出层
         当前(父)组件把showDialog=true的信息传递给子组件
         子组件会把false的信息回传回来对showDialog进行赋值
   
         弹出框组件只要被关闭，那么其value就由true变为false
         那么@input事件要执行，进而把false信息就回传回来了
       -->
       <more-action v-model="showDialog"></more-action>
     </div>
   </template>
   
   <script>
   // 对com-moreaction.vue弹出框组件做 导入、注册、使用
   import MoreAction from './com-moreaction.vue'
   
   // 导入获得文章的api函数
   import { apiArticleList } from '@/api/article.js'
   export default {
     name: 'com-article',
     components: {
       MoreAction
     },
     data () {
       return {
         showDialog: false, // 控制子组件弹出框是否显示
      		……
       }
     },
     methods: {
       // 展示更多操作的弹层
       displayDialog () {
         this.showDialog = true
       },
   ```

`效果`：

![1583651847132](img(online)/1583651847132.png)



## 页面布局

现在不感兴趣页面内容比较简单，本质上要形成具体操作项目，故要进行布局内容设计，并且是分为**一级项目明细** 和 **二级项目明细**的，它们不能同时显示，相反要切换显示

`目标`：

​	点击对话框中的对应cell切换显示两套布局效果



van-cell单元格组件

官网详情：  https://youzan.github.io/vant/#/zh-CN/cell 



在home/components/com-moreaction.vue设置如下代码：

> closed：使得对话框关闭，一级菜单被激活
>
> van-cell-group
>
> van-cell
>
> data成员创建

```html
<template>
  <div>
    <!-- 暂时表现弹出框效果
  v-model：设置弹出框是否显示 true显示、false不显示
  title：弹出框标题，可以不设置
  show-cancel-button：显示取消按钮
  :showConfirmButton="false" 不要显示取消按钮，false是boolean值
  showConfirmButton="false" false是字符串

  closeOnClickOverlay 是否在点击遮罩层后关闭弹窗,不要绑定内容，就是true被绑定
  :closeOnClickOverlay="true"

  closed 关闭弹窗时触发,isOneLevel=true，使得一级菜单被设置激活
    -->
    <van-dialog
      :value="value"
      @input="$emit('input',$event)"
      :showConfirmButton="false"
      closeOnClickOverlay
      @closed="isOneLevel=true"
    >
      <van-cell-group v-if="isOneLevel">
        <!-- 一级菜单 -->
        <van-cell title="不感兴趣" icon="location-o"></van-cell>
        <van-cell title="反馈垃圾内容" icon="location-o" is-link @click="isOneLevel=false"></van-cell>
        <van-cell title="拉黑作者" icon="location-o"></van-cell>
      </van-cell-group>
      <van-cell-group v-else>
        <!-- 二级菜单 -->
        <van-cell icon="arrow-left" @click="isOneLevel=true"></van-cell>
        <van-cell title="其他问题" icon="location-o"></van-cell>
        <van-cell title="标题夸张" icon="location-o"></van-cell>
        <van-cell title="低俗色情" icon="location-o"></van-cell>
        <van-cell title="错别字多" icon="location-o"></van-cell>
        <van-cell title="旧闻重复" icon="location-o"></van-cell>
        <van-cell title="广告软文" icon="location-o"></van-cell>
        <van-cell title="内容不实" icon="location-o"></van-cell>
        <van-cell title="涉嫌违法犯罪" icon="location-o"></van-cell>
        <van-cell title="侵权" icon="location-o"></van-cell>
      </van-cell-group>

    </van-dialog>
    <!-- :value+@input 是 v-model的体现
        @input="$emit('input')" $emit调用input事件，把感知到的信息
        传递给事件对应的v-model成员里边，即父组件的showDialog
        当前组件，鼠标单击对话框旁处，就可以使得value属性值为false
        这个false信息要传递给showDialog，这可以使得后续该弹出框"不断"被展示出来

        理论上代码应该为：$emit('input',$event.target.value)
        实际上不要设置$event.target.value，设置到不对，因为
        van-dialog是组件，不是普通表单域，$event.target.value不能表达出来当前组件的value属性信息
        @input="$emit('input',$event)" 在van-dialog内部会被"封装"为
        $emit('input',$event.target.value)

        组件标签都是：@input="$emit('input',$event)"
        普通表单域：$emit('input',$event.target.value)
    -->
  </div>
</template>

<script>
export default {
  name: 'more-action',
  props: ['value'],
  data () {
    return {
      isOneLevel: true // 控制一级、二级信息明细显示
    }
  }
}
</script>

<style lang="less" scoped>
</style>

```

> is-link	是否展示右侧箭头并开启点击反馈
>
> icon   左侧 图标名称 或图片链接

`效果`：

![1580379650139](img(online)/1580379650139.png)



## 处理

### 封装api

用户对文章不感兴趣，需要让**服务器**知道，这样下次服务器就不给**推送**类似文章了，故要制作api函数，使得可以像服务器发送请求

`目标`：

​	对 不感兴趣 文章做处理

`代码`：

在api/article.js文件封装api方法

接口：【对文章不喜欢】

```js
/**
 * 对文章不感兴趣处理
 * @param {目标文章id} articleID
 */
export function apiArticleDislike (articleID) {
  return request({
    url: '/app/v1_0/article/dislikes',
    method: 'post',
    data: {
      target: articleID
    }
  })
}
```



### 传递文章id 和 初期处理

> 文章信息在 com-article.vue 组件里边，
>
> 不感兴趣处理 在 com-moreaction.vue组件里边，
>
> com-article.vue  是 父组件， com-moreaction.vue 是子组件
>
> 故要通过 **父/子组件传值**  技术 把被目标文章id从  com-article.vue组件传递给  com-moreaction.vue组件，才能让子组件完成相关处理



`目标`：

​	实现对不感兴趣文章的处理



在文章列表页面，要把**文章的id**当参数传递给  更多操作  组件



`步骤`：

1. 在`home/components/com-article.vue`中进行处理

   > 处理目标文章id具体为：
   >
   > 1. 声明data成员nowArticleID
   > 2. 叉号按钮事件 接收传递 目标文章id   @click="displayDialog(item.art_id.toString())"
   > 3. 事件中把文章id赋予给 nowArticleID   this.nowArticleID = artID
   > 4. nowArticleID目标文章id  通过属性值传递给子组件  more-action

   ```vue
   <!-- 2. 事件中传递目标文章id-->
   <van-icon name="close" style="float:right;" 
             @click="displayDialog(item.art_id.toString())"/>
   ……
   <!-- 4. 父子组件传值传递文章id-->
   <more-action v-model="showDialog" :articleID="nowArticleID" ></more-action>
   ……
   <script>
     data(){
       return {
         nowArticleID: '', // 1. 不感兴趣文章id
         ……
       }
     }
     methods:{
       /**
        * 显示更多操作对话框
        * artID: 不喜欢文章id
        */
       displayDialog (artID) {
         this.showDialog = true
         // 3. 把文章id赋予给data成员
         this.nowArticleID = artID
       },  
     }
   
   </script>
   ```

   

2. `home/components/com-moreaction.vue`的处理

   > 1. 给不感兴趣 按钮生click事件
   >
   > 2. import导入 不感兴趣 的api接口方法
   >
   > 3. props接收父传递来的articleID文章id
   >
   > 4. articleDislike()方法处理 不感兴趣文章

   ```vue
   <van-cell icon="location-o" title="不感兴趣" @click="articleDislike()"/>
   ……
   <script>
     // 导入api模块函数
     import { apiArticleDislike } from '@/api/article'
     props: {
       ……
       // 接收不喜欢文章id
       articleID: {
         type: String,
         required:true
       }
     },
     methods: {
       /**
        * 对不感兴趣文章做处理
        */
       async articleDislike () {
         const result = await apiArticleDislike(this.articleID)
      		console.log(result)
       }
     }
</script>
   ```
   
   > 



现在针对文章进行“不感兴趣” 操作，可以看到执行成功效果

![1580435734551](img(online)/1580435734551.png)





`注意`：

​	我这点击**不感兴趣**的时候，报错401，退出登录，再登录然后再点击**不感兴趣**还是报401，清除浏览器缓存之后，这个问题也没有解决

​	文章不感兴趣操作需要确保用户处于登录状态，针对上述问题，可以通过如下方法解决

解决：
1. 请确保用户登录系统后，是否通过vuex保存用户信息
    即在 user/login.vue  的login方法中是否有 this.$store.commit()语句
2. 如果步骤1已经完成，再确保 request.js axios请求拦截器配置token
   "Bearer    " 后边有一个空格



### 客户端处理

文章不感兴趣操作完毕要做如下事宜

1. 关闭对话框

2. 成功提示

3. 文章列表清除该文章，该处要做的逻辑是

   父组件：com-article.vue 声明给more-action子组件声明事件，完成文章的清除操作

   子组件：com-moreaction.vue 通过 $emit调用事件，触发父组件做处理

`目标`：

​	对不感兴趣文章处理完毕，视图要做更新操作，清除  不喜欢的文章

`步骤`：

1. `home/components/com-article.vue` 父组件中 处理

   声明@事件 和 methods处理

   ```html
   <more-action v-model="showDialog" 
                :articleID="nowArticleID" 
                @dislikeSuccess="handleDislikeSuccess"></more-action>
   
   ```

   

   ```js
   methods: {
       // 文章不感兴趣的处理处理，清除目标文章
       handleDislikeSuccess () {
         // 让 nowArticleID 文章在列表中消失
         // 1. 获得目标文章id在文章列表中的下标序号
         //    findIndex()是数组的一个方法，可以通过条件获得指定目标在数组列表中的"下标序号"，有遍历机制
         // 各种底层方法api：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide
         const index = this.articleList.findIndex((item) => {
           // 满足条件就return为true信息出来，那么当前项目的下标序号就获得的到了
           return item.art_id.toString() === this.nowArticleID
         })
         // 2. 通过下标序号从列表中删除指定的文章
         // 数组.splice(下标, 长度)
         this.articleList.splice(index, 1)
         // (只是页面级删除)
       },
     ……
   }
   ```

   > 对应事件处理驱动

2. `home/components/com-moreaction.vue` 中 处理

   通过$emit调用自己的事件

   ```js
   methods: {
       // 文章不感兴趣处理
       async articleDislike () {
         // 调用api
         // 当前处理，正常情况成功率100%
         await apiArticleDislike(this.articleID)
   
         this.$toast.success('处理成功')
         // 关闭弹出框,修改父组件的showDialog的值为false，进而影响子组件关闭弹框
         this.$emit('input', false)
   
         // 调用自己的事件，使得父组件页面文章清除
         this.$emit('dislikeSuccess')
       }
   }
   ```

   > 文章删除成功，调用自己的事件方法做后续处理，同时关闭弹框，成功提示



`注意`：

1. 这里服务器端  不感兴趣文章 处理是，以后就不给推荐了，页面做一个假删除
2. 拉黑作者  的逻辑与不感兴趣的处理步骤完全一致，可自行研究





## 举报-处理

文章不感兴趣是以后都**不要**看着类似文章，而被举报的文章还仍然**可以显示**

服务器端要知道哪个文章被举报，以便采取处理措施，

因此大致过程是制作api，调用api，完成处理



`目标`：

​	实现文章举报处理功能

`步骤`：

1. 在  api/article.js  中创建api接口方法

   api接口：【举报文章】

   ```js
   /**
    * 对文章做举报处理
    * @param {文章id} articleID
    * @param {举报类型} type
    * 举报类型： 0-其他问题，1-标题夸张，2-低俗色情，3-错别字多，4-旧闻重复，5-广告软文，6-内容不实，
    * 7-涉嫌违法犯罪，8-侵权'
    * {articleID, type, remark=''} 是对象解构赋值用法，这样可以清楚知道当前接口需要哪些参数，
    * 不用再查看接口文档了，非常方便
    *
    * 对象解构赋值可以设置默认值  例如 remark=''
    */
   export function apiArticleReport ({ articleID, type, remark = '' }) {
     return request({
       url: '/app/v1_0/article/reports',
       method: 'post',
       data: {
         target: articleID,
         // 对象成员简易赋值，完整写法：type:type
         type,
         remark // 其他问题 的附加说明
       }
     })
   }
   
   ```

   

2. com-moreaction.vue 中处理

   定义data成员设置举报类型信息，遍历展示举报项目信息

   给举报项目设置click事件，触发举报

   定义methods方法，实施举报


template

```html
<!--
v-for遍历展示动态举报数据
click单击事件，进行举报操作-->
<van-cell-group v-else>
  <van-cell icon="arrow-left" @click="isOneLevel=true"></van-cell>
  <van-cell
            v-for="item in reportsList"
            :key="item.value"
            :title="item.title"
            icon="location-o"
            @click="articleReport(item.value)"
            />
</van-cell-group>
```

import导入 api函数

```js
import { apiArticleReport } from '@/api/article.js'
```



data

```js
// 举报类型：
reportsList: [
  { title: '其他问题', value: 0 },
  { title: '标题夸张', value: 1 },
  { title: '低俗色情', value: 2 },
  { title: '错别字多', value: 3 },
  { title: '旧闻重复', value: 4 },
  { title: '广告软文', value: 5 },
  { title: '内容不实', value: 6 },
  { title: '涉嫌违法犯罪', value: 7 },
  { title: '侵权', value: 8 }
],
```



methods

```js
// 文章举报
// type:举报类型
async articleReport (type) {
  // type:是对象成员简易赋值type:type
  // 文章举报要么成功、要么失败(文章被重复举报)，所以try/catch要介入
  try {
    // 只要apiapiArticleReport 函数发生致命名错，其他语句都没有问题
    const obj = { articleID: this.articleID, type }
    await apiArticleReport(obj)
  } catch (err) {
    // return:停止catch以外的代码执行
    if (err.response.status === 409) {
      return this.$toast.fail('文章已经被举报过了')
    } else {
      return this.$toast.fail('文章举报失败')
    }
  }

  // 成功提示
  this.$toast.success('举报成功！')
  // 弹出框消失
  this.$emit('input', false)
},
```

> try/catch 可以对服务器返回的异常信息进行捕捉，如果不设置，会造成程序中断执行



`注意`：

​	409 表示文章被举报过

`效果`：

![1580438667938](img(online)/1580438667938.png)



# 文章下拉刷新

对下拉文章 进行数据更新，与瀑布不同，下拉文章的追加应该是**unshift头部**进行

最新文章理论上有可能不会获得到，要进行判断并给与不同提示



`目标`：

​	实现下拉获取最新的文章列表信息功能，前置追加

 

`步骤`

`home/components/com-article.vue`做如下操作

1. 给van-pull-refresh组件配置相关属性

   ```html
   <van-pull-refresh
                     v-model="isLoading" // 下拉动画控制
                     @refresh="onRefresh" // 下拉事件声明
                     :success-text="downSuccessText" // 下拉完毕提示信息
                     :success-duration="1000" // 下拉完毕提示信息停留时长
                     >
   ```

   > 注意：
   >
   > :success-duration="1000" 表示接收一个整型的1000，组件内部固定要求

2. 组件实例的data中声明downSuccessText成员

   ```js
   // 下拉动作完成的文字提示
   downSuccessText: '', // 文章更新成功 / 文章已经是最新的
   ```

   

3. 完善onRefresh下拉动作动作

   ```js
   // 下拉刷新
   async onRefresh () {
     await this.$sleep(800)
   
     // 获得文章列表数据
     const articles = await this.getArticleList()
   
     // 判断是否有获得到最新的文章
     if (articles.results.length > 0) {
       // 有获得到 unshift 数组前置追加元素
       this.articleList.unshift(...articles.results)
       // 更新时间戳
       this.ts = articles.pre_timestamp // 使得继续请求，可以获得下页数据
       this.downSuccessText = '文章更新成功'
     } else {
       // 没有最新的文章了，页面要给与提示
       this.downSuccessText = '文章已经是最新的'
     }
     this.isLoading = false // 下拉动画消失[加载完成了]
   },
   ```




`效果`：

![1581738919551](img(online)/1581738919551.png)


