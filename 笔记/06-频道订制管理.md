

# 频道订制管理

# 三杠按钮

`目标`：

​	向频道列表 右侧 添加  三个横杠 操作按钮

`代码`：

`home/index.vue`->tempalte

```html
<van-tabs v-model="activeChannelIndex">
  <!-- 给标签页设置图标，用法是命名插槽
  slot="nav-left/right" 图标放置的位置
  class="channel-more"  下述设置css样式
  -->
  <div slot="nav-right" class="channel-more">
    <!-- 图标  name="wap-nav" 3杠图标 -->
    <van-icon name="wap-nav"/>
  </div>
  <!----省略>
```

> 额外增加channel-more属性值，以便css控制样式
>
> slot="nav-right" 是标签组件提供的插槽用法，表示要给标签页右侧设置显示内容，如果是nav-left就是给左侧内容显示内容
>
> van-tabs标签页组件内部可以通过**“命名插槽”**方式给标签页 左侧 或 右侧 设置内容显示

`home/index.vue`->style

```css
  /*给 更多 频道设置样式*/
  .channel-more {
    position: fixed;
    right: 0;
    background-color: white;
    line-height: 88px;
    height: 88px;
    width: 90px;
    text-align: center;
    font-size: 40px;
  }
  /*频道标签页宽度减小一些*/
  /deep/ .van-tabs__wrap {
    width: 90%; /*设置频道列表最大宽度，可以避免最后一个频道被按钮覆盖住*/
  }
```



`效果`：

![1580453509072](img(online)/1580453509072.png)



# 弹出层

## 显示与隐藏

> 弹出层内部的业务相对比较复杂，处于开发、维护便利的角度出发
> 要给弹出层相关逻辑代码封装为一个“独立组件”
> 该组件名称为： home/components/com-channel.vue 【子组件】
> home/index.vue 作为【父组件】对子组件到导入、注册、使用
>
> 1. 创建子组件，并绘制弹出层相关代码
> 2. 父组件导入、注册、使用 子组件
>    期间会用到 组件里边使用v-model 技术
>    (与之前文章举报弹出框操作逻辑类似)
> 3. 父组件 与 子组件 要做 v-model :value  @input 的配合



`目标`：

​	点击三杠操作按钮，有**弹出层**效果



单击三杠按钮后要对频道做增加、减少操作，相对比较复杂，故要设置独立组件操作



`知识点`：

van-popup展示弹出层组件

官网详情： https://youzan.github.io/vant/#/zh-CN/popup 

```html
<!-- 暂时体现弹出层效果
v-model="show"  控制弹出层是否显示true/false，
单击遮罩层，弹出层关闭，这show自动为false
position="bottom"  弹出层从底部出来
:style="{ height: '40%' }" 弹出层高度
closeable  有关闭按钮
close-icon-position="top-left"  按钮在左上角显示
round 有圆角
-->
<van-popup
           v-model="show"
           position="bottom"
           :style="{ height: '40%' }"
           closeable
           close-icon-position="top-left"
           round
           ></van-popup>
```



`步骤`

1. 新建home/components/com-channel.vue组件

   ```vue
   <template>
     <div>
       <!-- 弹出层 -->
       <!-- 暂时体现弹出层效果
             v-model="show"  控制弹出层是否显示true/false，
                             单击遮罩层，弹出层关闭，这show自动为false
             position="bottom"  弹出层从底部出来
             :style="{ height: '40%' }" 弹出层高度
             closeable  有关闭按钮
             close-icon-position="top-left"  按钮在左上角显示
             round 有圆角
       -->
       <van-popup
         :value="value"
         @input="$emit('input',$event)"
         position="bottom"
         :style="{ height: '40%' }"
         closeable
         close-icon-position="top-left"
         round
       ></van-popup>
     </div>
   </template>
   
   <script>
   export default {
     name: 'com-channel',
     // 接收v-model的数据信息
     props: {
       value: {
         type: Boolean,
         default: false
       }
     }
   }
   </script>
   
   <style lang="less" scoped>
   </style>
   
   ```
   
> value和@input结合使得可以控制弹出层显示 或 隐藏
   >
   > props->value 接收父组件传递过来的数据(通过v-model传递来的)

2. home/index.vue 处理

   > 1. 三杠设置单击事件，使得展示频道弹出层
   > 2. 对com-channel做  导入、注册、使用
   > 3. 给com-channel组件标签设置v-model双向绑定
   
   ```vue
   <!--给频道3杠按钮设置单击click事件-->
   <!-- 给标签页的左侧或右侧通过命名插槽设置内容 -->
   <div slot="nav-right" class="channel-more" @click="showPopup=true">
     <!-- 三杠图标 -->
     <van-icon name="wap-nav"/>
   </div>
   ……
   <!-- 应用频道子组件弹出层 -->
   <com-channel v-model="showPopup"></com-channel>
   ……
   <script>
   // 导入com-channel.vue
   import ComChannel from './components/com-channel.vue'
   	……
     // 注册组件
     components: {
       ComChannel
       ……
     },
     ……
     // data:
     showPopup: false, // 控制子组件弹出层是否显示
   </script>
   ```

`效果`：

![1583725552059](img(online)/1583725552059.png)

`注意`： 

​	频道弹出层popup的显示/隐藏 的 原理 与 不感兴趣的dialog弹出框完全一致，

​	即组件标签应用v-model，控制子组件表单域的状态，具体通过:value+@input 实现接受控制的







## 页面设计

`目标`：

​	对弹出层进行频道布局设计



在`com-channel.vue`中设计如下代码  (直接复制应用即可，没有新技术)：

其中涉及的组件标签有  van-grid/van-grid-item **宫格**组件 https://youzan.github.io/vant/#/zh-CN/grid 

 宫格可以在水平方向上把页面分隔成等宽度的区块，用于展示内容或进行页面导航 

```vue
<template>
  <van-popup
    :value="value"
    @input="$emit('input',$event)"
    closeable
    close-icon-position="top-left"
    round
    position="bottom"
    :style="{ height: '95%' }"
  >
    <div class="channel">
      <div class="channel-head">
        <div>
          <span class="title">我的频道</span>
          <span class="desc">点击进入频道</span>
        </div>
        <div>
          <van-button type="danger" plain size="mini" round>编辑</van-button>
        </div>
      </div>
      <!--van-grid 没有设置column-num属性，默认是4列-->
      <van-grid class="channel-content" :gutter="10" clickable>
        <van-grid-item v-for="value in 8" :key="value">
          <span class="text">文字</span>
          <!-- <van-icon class="close-icon" name="close" /> -->
        </van-grid-item>
      </van-grid>
    </div>

    <div class="channel">
      <div class="channel-head">
        <div>
          <span class="title">频道推荐</span>
          <span class="desc">点击添加频道</span>
        </div>
      </div>
      <van-grid class="channel-content" :gutter="10" clickable>
        <van-grid-item v-for="value in 8" :key="value">
          <div class="info">
            <span class="text">文字</span>
          </div>
        </van-grid-item>
      </van-grid>
    </div>
  </van-popup>
</template>

```

```vue
<style lang="less" scoped>
.channel {
  margin-top:70px;
  .channel-head {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px;
    .title {
      font-size: 30px;
      margin-right: 5px;
    }
    .desc {
      font-size: 16px;
      color:gray;
    }
  }
  .channel-content {
    .text {
      font-size: 16px;
    }
    .active {
      color: red;
    }
    .close-icon {
      font-size: 20px;
      position: absolute;
      top: -5px;
      right: -5px;
      z-index: 999;
      background-color: #fff;
    }
    .info {
      display: flex;
      align-items: center;
    }
  }
}
</style>

```



`效果`：

![1575786819475](img(online)/1575786819475.png)



# 我的频道

> 把home首页面，用户真实拥有的频道数据 放到 com-channel.vue 频道页面
> 中展示出来，这里边涉及父、子组件传值
> 父：home/index.vue
> 子：home/components/com-channel.vue
>
> 给“激活频道”设置高亮红色效果
> 父：传递当前激活频道的下标
> 子：接收激活频道的下标，遍历频道的时候，判断下标与
>     传递过来的是否一致，一致就是红色高亮

`目标`：

​	将**我的频道**的数据渲染出来  并 根据当前激活项目设置高亮样式

`步骤`：

1. 父组件传递 channelList(我的频道数据)和activeChannelIndex(激活项目的下标)
2. 子组件接收 channelList和activeChannelIndex
3. 子组件遍历 channelList, 并判断是否设置激活样式(红色)

`代码`：

`home/index.vue`->使用子组件时 传值

```html
<!-- 频道操作
:channelList="channelList" 把当前用户拥有的频道传递给频道组件里边显示
:activeChannelIndex="activeChannelIndex" 当前激活频道项目的下标
-->
<com-channel
             v-model="showChannel"
             :channelList="channelList"
             :activeChannelIndex="activeChannelIndex"
             ></com-channel>
```

`com-channel.vue`

```vue
<!--van-grid 没有设置column-num属性，默认是4列-->
<van-grid class="channel-content" :gutter="10" clickable>
  <!-- grid-item宫格单元
    宫格内容表现：
    1. text属性,设置简单内容
    2. 匿名插槽，设置复杂内容
    -->
  <van-grid-item v-for="(item,k) in channelList" :key="item.id">
    <span class="text"
          :style="{color:k===activeChannelIndex?'red':''}">
      {{item.name}}
    </span>
    <!-- <van-icon class="close-icon" name="close" /> -->
  </van-grid-item>
</van-grid>

……
<script>
export default {
  name: 'com-channel',
  props: {
    // 接收父组件v-model的数据信息
    value: {
      type: Boolean,
      default: false
    },
    // 父传递过来的"我的频道"数据
    channelList: {
      type: Array,
      // 数组的默认值要通过如下箭头函数方式设置
      default: () => []
    },
    // 当前激活频道的下标
    activeChannelIndex: {
      type: Number,
      default: 0
    }
  }
}
</script>
```

`效果`：

![1575788358204](img(online)/1575788358204.png)



# 所有频道

## 获得全部

`目标`：

​	获得全部频道数据

`步骤`

1. 封装api方法获取所有频道数据

2. 在com-channel.vue中获取所有频道数据(导入api、data、methods、created)

   

`代码`：

api/channel.js 封装api方法获得**全部**频道

```js
/**
 * 获得全部频道
 */
export function apiChannelAll () {
  return request({
    url: '/app/v1_0/channels',
    method: 'get'
  })
}

```

> (接口：【全部频道列表】)

com-channel.vue 实例部分

> 1. 导入api
> 2. 创建data成员接收全部频道
> 3. methods方法调用api获得频道
> 4. created调用methods方法

```js
// 导入获得频道的api函数:全部频道
import { apiChannelAll } from '@/api/channel.js'

data () {
  return {
    channelAll: [] // 全部频道数据
  }
},
  created () {
    // 获得全部频道
    this.getChannelAll()
  },
    methods: {
      // 获得"全部"频道数据
      async getChannelAll () {
        const result = await apiChannelAll()
        this.channelAll = result.channels
      }
    },
```



## 展示剩余的频道

`目标`：

​	从 “全部频道” 里边把 “我的频道” 筛选过滤掉，展示剩余的频道数据

1. 我的频道数据:channelList
2. 全部频道数据:channelAll



剩余频道是  **全部频道**  通过算法对    **我的频道**   做减法的结果，即相关data做合成处理得出一个的数据，这在Vue里边要借助**computed计算属性**进行操作



`步骤`：

1. 添加计算属性restChannels,用来保存剩余数据
2. 获取**我的频道**的id
3. 从 **全部频道** 数据中过滤掉 **我的频道**
4. 对剩余的频道做展示

`代码`：

`com-channel.vue`创建channelRest

```js
// 计算属性有缓存，相关data不变化，"结果"会缓存，提升系统性能
computed: {
  // 获得剩余频道( 全部频道-我的频道 )
  restChannel () {
    // 1. 把 我的频道  的 各个id获得出来，集成一个数组返回 [10,15,23,44……]
    //    map是映射方法，遍历数组，并以"数组"形式返回修饰后的每个单元信息信息
    //    参考：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide
    const userChannelIDs = this.channelList.map(item => {
      return item.id
    })

    // 2. 对 全部频道 做过滤，把“不符合” 我的频道 的项目收集并返回出来，就是【剩余频道】
    //    数组.filter()  过滤方法，把符合条件的数组元素通过“新数组”给与返回
    //    (全部频道 去除 我的频道 给与返回)
    const rest = this.channelAll.filter(item => {
      // 我的频道  里边不包含当前项目，就给与收集
      // 判断我的频道id集合 是否包含当前项目，不包含的才收集
      // 数组.includes(元素)  判断数组中是否有出现某个元素，返回Boolean
      return !userChannelIDs.includes(item.id)
    })
    return rest
  }
},
```

`com-channel.vue`模板展示，直接对做剩余频道restChannel遍历输出

```html
<van-grid class="channel-content" :gutter="10" clickable>
  <van-grid-item v-for="item in restChannel" :key="item.id">
    <div class="info">
      <span class="text">{{item.name}}</span>
    </div>
  </van-grid-item>
</van-grid>
```

`效果`：

![1580456393935](img(online)/1580456393935.png)

`注意`：

1. map[映射]方法：对数组进行遍历，返回一个新数组，元素个数与被处理数组一致，但是元素的value值是map处理过的
2. 数组的filter方法，对数组的元素进行过滤，把符合条件的元素重新组成数组返回
3. 数组的includes方法，判断数组是否包含指定的元素
4. 以上各个方法学习可以参考：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide



# 本地持久化

现在**频道信息**的获取都需要axios向服务端发送请求

实际情况是，频道信息比较稳定，不随意发生变化，频繁先服务器发请求实在没有必要

我们要这样处理：

**第一次**获取频道信息，要通过axios先服务器发请求，回来的频道信息立即就在**本地localStorage**中给保存起来，

**第二、三、四……次**获取频道就不用执行axios，直接向本地索取数据即可

这样既节省的服务器、带宽各方面的资源消耗，还加快了速度的显示，提升了用户的体验



需要注意的是：本地存储频道要把 游客  和  登录用户 区分开，各自存储自己的

![1583676929800](img(online)/1583676929800.png)

实现：

在api/channel.js 中对获取用户频道数据的函数做升级改造如下：

1. async和await方式(记住)

   ```js
   // 导入axios对象
   import request from '@/utils/request.js'
   
   // 导入store(Vuex)，可以判断用户是否登录系统 store.state.user.token?'登录':'未登录'
   import store from '@/store/index.js'
   
   // 频道相关api函数配置文件
   
   // 本地持久化存储频道设置的key(游客 和 登录用户 分别设置)
   const CHANNEL_KEY_TRAVEL = 'hm-channel-travel' // 游客key
   const CHANNEL_KET_VIP = 'hm-channel-vip' // 登录用户Key
   /**
    * 获取用户的频道列表数据
    * 一般数据获取请求方式都是get
    * 当前函数不要传递参数(从【接口文档】可知)
    *
    * 应用端明确要求如下函数返回"Promise对象"结果
    * 给函数前边设置async，那么这个函数return返回结果以"Promise对象"形式体现
    */
   export async function apiChannelList () {
     // 1. 从缓存localStorage里边获得频道(注意区分用户是否有登录系统)
   
     // 根据用户是否登录系统获得对应的localStorage操作的key
     const key = store.state.user.token ? CHANNEL_KET_VIP : CHANNEL_KEY_TRAVEL
     // 读取缓存的频道数据:null  实体字符串
     // 频道数据在localStorage中存储的样子：[{id:xx,name:xx},{id:xx,name:xx},{id:xx,name:xx},……]
     // 是“数组对象集”，但是类型是字符串
     const cacheChannels = localStorage.getItem(key)
   
     // 2. 判断是否有缓存频道数据
     if (cacheChannels) {
       // 有数据，直接返回应用
       return { channels: JSON.parse(cacheChannels) }
     } else {
       // 没有数据，就走axios获得数据应用
       // 注意：request前边需要设置await，保证同步执行，后续代码可以正常获得rst结果
       const rst = await request({
         url: '/app/v1_0/user/channels',
         method: 'get'
       })
       // 把获得好的数据存储给localStorage，以便下次使用
       localStorage.setItem(key, JSON.stringify(rst.channels))
       // 数据对外输出应用即可
       return rst
     }
     // 应用组件使用的频道数据：
     // {channels:[{id:xx,name:xx},{id:xx,name:xx},{id:xx,name:xx},……]}
   }
   
   ```

   

2. new Promise()方法(了解即可)

```js
import store from '@/store' // 导入vuex模块，以便知道当前用户是否登录系统

// 本地持久化存储频道设置的key(游客 和 登录用户 分别设置)
const CHANNEL_KEY_TRAVEL = 'hm-channel-travel' // 游客key
const CHANNEL_KET_VIP = 'hm-channel-vip' // 登录用户Key

// 获得用户频道数据
export function apiChannelList () {
  // 通过Promise封装，通过resolve返回输出具体信息，await修饰就接收到了
  // 因为所有api接口的返回结果都是Promise对象，这样做兼容性更好，应用层代码就不用改了
  return new Promise(async (resolve) => {
    // 判断用户是否登录，并执行不同的key(localStorage)
    const key = store.state.user.token ? CHANNEL_KET_VIP : CHANNEL_KEY_TRAVEL

    // 获取本地频道数据
    const cacheChannels = localStorage.getItem(key)

    // localStorage内部存储的频道数据样子
    // [{id:xx,name:xx},{id:xx,name:xx}……]

    if (cacheChannels) {
      // 输出频道数据给外部
      resolve({ channels: JSON.parse(cacheChannels) })
    } else {
      // 频道没有被缓存
      const result = await request({
        url: '/app/v1_0/user/channels',
        method: 'get'
      })
      // 本地存储频道数据
      localStorage.setItem(key, JSON.stringify(result.channels))
      // 输出频道数据给外部
      resolve(result)
    }
  })
}
```





现在无论是 **游客**  还是 **登录用户** ，第一次获取频道数据都是发送axios请求，后续第二、三、四次请求时就直接读取本地缓存数据了，极大提高系统性能，后期针对频道的**添加**、**删除**等操作也要通过本地进行操作



localStorage里边缓存好的频道数据：

![1583743438667](img(online)/1583743438667.png)



`注意`：

​	用户如果退出系统，本地的数据就被清除



# 添加频道并持久化

> 1. 添加频道并持久化
>     1. 把“频道推荐”项目拿出来给到 “我的频道”就完成添加逻辑了
>        (当前添加只是页面级添加，f5刷新后，又没有了)
>     2. 持久添加，本地localStorage也要做添加
>
> 实施：
> 1. 持久添加封装一个api函数(实现localStorage持久存储)
> 2. 在com-channel.vue里边做如下逻辑
>     A. api导入
>     B. 给“频道推荐”项目设置click单击事件
>         做添加频道处理(我的频道 要增加该项目、localStorage也要增加)
>     C. 制作methods方法与click配合

`目标`：

​	单击**推荐频道**中的某个项目，把其添加到**我的频道**里

`步骤`：

1. 创建api方法，api/channel.js

   ```js
   /**
    * 添加频道
    * @param {被添加的频道,对象} channel  {id:xx, name:xx}
    * 潜规则，api函数返回结果就是“Promise对象”(根据之前封装axios来的)
    * 处理：async + return
    */
   export async function apiChannelAdd (channel) {
     // 判断用户是否登录，获得对象key
     const key = store.state.user.token ? CHANNEL_KET_VIP : CHANNEL_KEY_TRAVEL
   
     // 从localStorage里边把已经拥有的频道获得出来,String--->Object
     // [{id:xx,name:xx},{id:xx,name:xx}……]  数组对象集
     const cacheChannels = JSON.parse(localStorage.getItem(key))
     // 对 获取出来的频道 做添加操作，push
     cacheChannels.push(channel)
     // 再把添加好的“总的频道列表”数据 维护到localStorage里边去
     localStorage.setItem(key, JSON.stringify(cacheChannels))
   
     // 上述代码都是非常ok的，本身不需要返回任何信息(应用端也不需要)，就返回null即可
     // 应用端： const rst = await apiChannelAdd(xx)
     //          console.log(rst) null
     return null
   }
   
   ```
   
   > 不用考虑频道为空的情形，因为不存在，至少还有“推荐”
   >
   > 根据规则，所有api返回结果都是Promise对象，所以在function前边设置async
   
   
   
2. 在com-channel.vue中做如下操作

   给**推荐频道**绑定事件

   ```vue
   <!-- @click声明事件，使得推荐频道 被单击可以添加给 我的频道
   同时传递item参数，{id:xx,name:xx} 是对象
   -->
<van-grid-item v-for="item in restChannel" :key="item.id"
                  @click="restToUser(item)">
```
   

   
   import导入api函数、methods方法实现添加频道逻辑
   
   ```js
   // 导入获得频道的api函数:全部频道、添加频道
   import { apiChannelAll, apiChannelAdd } from '@/api/channel.js'
   
   // 添加频道(剩余频道---->我的频道)
   // @param channel:被添加的频道 {id:xx,name:xx} 对象
   restToUser (channel) {
     // 1. 对“我的频道channelList”成员属性进行添加，使得发生响应式，页面可以看到
     //    channelList是"我的频道"，是父组件给传递过来的，我们要直接对其进行操作
     //    当前组件通过props接收的，其本身还是一个"对象[{},{},{}..]"
     //    父子组件传递对象是"引用方式"：
     //               父、子组件是同一个对象的不同名称引用而已
  //               子组件修改了该对象，父组件也会感知到
     //    结论：添加好的频道 在 home/index.vue 的标签页上页会立即显示
     //    (父、子组件应用的数据，都是内存，页面刷新后，新添加的就没有了)
     this.channelList.push(channel)
     // 2. localStorage持久添加，完成此步骤后，新添加的数据就不会丢失了（即使刷新页面）
     apiChannelAdd(channel)
   },
   ```
   
   



`效果`：

![1580460749311](img(online)/1580460749311.png)

![1580460791911](img(online)/1580460791911.png)



现在进行**添加频道**操作，会有如下效果：

1. 我的频道 更新添加，响应式---->channelList成员
2. 频道推荐 会减少对应的频道，响应式，剩余频道---->computed---->channelList+channelAll合成
3. 本地localStorage会更新添加，有调用api
4. home父页面也会把添加好的频道展示出来，父、子组件关于channelList是不同引用(名字)而已





# 删除频道

## 显示删除按钮

`目标`：

​	**我的频道**删除按钮显示



`步骤`：

删除icon组件应用

给 我的频道 设置删除按钮图标

```vue
<van-grid-item v-for="(item,k) in channelList" :key="item.id">
  <span class="text"
        :style="{color:k===activeChannelIndex?'red':''}">
    {{item.name}}
  </span>
  <!-- 删除的叉号图标标志
class="close-icon" 设置样式的
v-show="k>0" 使得 推荐 项目不显示叉号按钮
-->
  <van-icon v-show="k>0" class="close-icon" name="close" />
```

`效果`：

![1581909701736](img(online)/1581909701736.png)

`注意`：

“推荐”频道，不要设置叉号，业务上不允许删除，是固定的



## 状态切换

> 频道要想被删除，首先需要进入编辑状态，再完成处理逻辑
>
> 如果频道删除完成，要退出编辑状态，进入正常状态



`目标`：

​	单击**编辑**按钮：显示**删除**图标 、显示**完成**按钮

​	单击**完成**按钮：隐藏**删除**图标 、显示**编辑**按钮



`步骤`：

​	在com-channel.vue中做如下操作

1. data 提供布尔属性控制删除的显示与隐藏

   ```js
   isEdit: false, // 是否进入编辑状态 true/false
   ```

2. 给**编辑**按钮绑定事件，修改 isEdit 布尔属性值，并判断显示**编辑**还是**完成**信息

   ```html
   <van-button type="danger" plain size="mini" round 
               @click="isEdit=!isEdit">
     {{isEdit?'完成':'编辑'}}
   </van-button>
   ```

   

3. 删除按钮图标根据 isEdit 绝对是否显示

   ```html
   <!--显示删除按钮，k>0 并且现在是编辑状态，才显示叉号按钮-->
   <van-icon class="close-icon" name="close"
               v-show="isEdit && k>0" />
   ```
   
4. 给popup弹出层设置**@closed**事件，使得关闭后，初始化编辑状态为完成的

   ```vue
   <van-popup
              :value="value"
              @input="$emit('input',$event)"
              position="bottom"
              :style="{ height: '95%' }"
              closeable
              close-icon-position="top-left"
              round
              @closed="isEdit=false"
              >
   ```

   

`效果`：

![1580461885255](img(online)/1580461885255.png)



## 删除并持久化

>     “我的频道”项目拿出来给到 “剩余频道”，就完成删除
>     1. 页面级-->响应式
>     2. localStorage持久删除-->固定结果(即使页面刷新也不改变)
>     
>     实施：
>     1. 制作叉号删除按钮
>     2. 删除状态 和 完成状态做切换
>         战略：通过data标志控制
>     3. api创建
>     4. 在com-channel.vue做逻辑处理
>         A. api导入
>         B. 我的频道 项目的"叉号标志"要设置单击click事件
>         C. methods方法完成删除处理(内存级、localStorage)
>

`目标`：

​	删除“我的频道”的某个项目

`步骤`：

1. 创建api方法，api/channel.js

```js
/**
 * 删除频道
 * @param {被删除的频道,对象} channel {id:xx, name:xx}
 */
export async function apiChannelDel (channel) {
  // 判断用户是否登录，获得对象key
  const key = store.state.user.token ? CHANNEL_KET_VIP : CHANNEL_KEY_TRAVEL

  // 1. 从localStorage里边获得目前拥有的频道
  // [{id:xx,name:xx},{id:xx,name:xx}……]  数组对象集
  const cacheChannels = JSON.parse(localStorage.getItem(key))

  // 2. 对拥有的频道做删除操作，从cacheChannels里边去除channel项目
  //    对"拥有的频道"做过滤，遍历，把 channel 给滤掉
  //    数组.filter(function(item){}回调函数参数)
  const tmpChannels = cacheChannels.filter(item => {
    // item: 代表遍历出来的每个数组元素单元
    // 判断当前项目如果“不是” channel 就收集,
    // 内部return接收true就收集当前数值元素项目，接收false就抛弃
    return channel.id !== item.id
  })

  // 3. 把删除后的剩余我的频道数据再存储给localStorage
  localStorage.setItem(key, JSON.stringify(tmpChannels))

  return null
}

```

> 不用考虑频道为空的情形，因为不存在，至少还有“推荐”



2. 在com-channel.vue中进行

给**删除按钮**绑定click事件

```html
<!-- 删除的叉号图标标志
class="close-icon" 设置样式的
v-show="k>0" 使得 推荐 项目不显示叉号按钮
isEdit: 表示进入编辑状态，才显示该图标
userToRest(item {id:xx,name:xx} 用户持久删除, k 项目下标序号 内存删除)
-->
<van-icon v-show="k>0 && isEdit" class="close-icon" name="close"
          @click="userToRest(item,k)" />
```

> 对被删除 频道  和 频道的下标序号 都当做参数进行传递



import导入api函数、methods方法实现删除频道逻辑

```js
// 导入 apiChannelDel 删除频道的函数
import { apiChannelAll, apiChannelAdd,apiChannelDel } from '@/api/channel'

// 删除频道(我的频道----->剩余频道)
// @param channel 被删除的频道 {id:xx,name:xx}
// @param index 被删除频道在我的频道列表中的下标序号
userToRest (channel, index) {
  // 1. 对channelList做页面内存级删除，使得有响应式效果
  //  A. 我的频道立即呈现删除效果，
  //  B. 剩余频道会增加删除的项目，
  //  C. 父页面home/index.vue也会体现删除效果)
  this.channelList.splice(index, 1)
  // 2. localStorage持久删除,f5刷新页面，被删除的数据也不出现了
  apiChannelDel(channel)
},
```

现在已经可以实现删除频道功能了，并且会有如下效果：

1. 我的频道 更新删除
2. 频道推荐 会更新显示返还的频道
3. 本地localStorage会更新删除频道
4. home父页面也会更新删除频道

效果：

![1580463327421](img(online)/1580463327421.png)



## 前置激活

>     要对最后一个项目做删除操作，并且其是“激活”状态的
>     经过调查，大多数人更喜欢再让前一个项目被激活使用，即linux
>     但是目前状态：
>     是第一个"推荐"被激活应用，与大多数人的体验不一致
>     
>     为什么呢？
>     答：这个频道是“标签页”项目，van-tabs,其内部有v-model设置哪个
>     项目被激活应用，内部走 activeChannelIndex 成员
>     activeChannelIndex=3  删除后  activeChannelIndex=3，这样标签页
>     会认为是"不合理"的，删除后项目的下标就是0/1/2，没有3的
>     标签页 如果判断 v-model绑定的内容值超出范围(不合理)，就自动调整v-model
>     的属性值为0，就是"推荐"被激活应用
>     
>     现在要做处理，使得上一个linux项目被激活选中
>     算法：
>         判断当前项目是最后一个，并且其还要被删除，删除完毕
>         就设置"前一个"项目被激活选中
>     
>         删除完毕判断：
>         删除项目的下标(3)===项目的总个数(3)[删除最后一个]  
>             && 激活项目的序号 等于 删除项目的下标[最后一个还是激活的]
>     
>         就说明是“最后一个激活”的项目被删除了
>         就要"前置激活"

> 现在情况是，当前频道是最后一个，并且其要被删除，那么在 **van-tabs** 频道切换标签来看，此时的频道激活下标序号(activeChannelIndex)是**非法**的，其内部就处理为**下标为0**的项目被激活使用(就是第一个项目)，这在业务上不太友好，更人性的处理应该是要让**前一个**项目被激活使用

`目标`：

​	实现前一个频道被激活使用

​	激活频道被删除后，后续没有频道，前置频道被激活做应用

​	

.sync和update实现子组件修改父组件的数据语法回顾：

```vue
父组件
  <com-channel  :xxx="yyy" @update:xxx="mod">
    mod(data){
    	this.yyy = data
    }
  // 上述过程可以简化为如下
  <com-channel  :xxx.sync="yyy">
子组件
  $emit('update:xxx',1234)
  // 父组件成员yyy就被修改为1234
```





`处理`：

在com-channel.vue删除频道**userToRest**的methods方法中做如下处理

```js
// 删除频道(我的频道----->剩余频道)
// @param channel 被删除的频道 {id:xx,name:xx}
// @param index 被删除频道在我的频道列表中的下标序号
userToRest (channel, index) {
  // 1. 对channelList做页面内存级删除，使得有响应式效果
  //  A. 我的频道立即呈现删除效果，
  //  B. 剩余频道会增加删除的项目，
  //  C. 父页面home/index.vue也会体现删除效果)
  this.channelList.splice(index, 1)
  // 2. localStorage持久删除,f5刷新页面，被删除的数据也不出现了
  apiChannelDel(channel)

  // 判断删除的如果是最后一个项目，并且还有被激活，就设置前一个项目激活
  if (index === this.channelList.length && this.activeChannelIndex === index) {
    // console.log('前一个项目被激活选中')
    // 设置activeChannelIndex = index-1
    // 当前子组件要去修改父组件的成员属性
    this.$emit('update:activeChannelIndex', index - 1)
  }
},
```



父组件home/index.vue 要给 activeChannelIndex设置sync调用，表示允许子组件修改

```vue
<com-channel
             v-model="showChannel"
             :channelList="channelList"
             :activeChannelIndex.sync="activeChannelIndex"
             ></com-channel>
```





`效果`：

![1580650261351](img(online)/1580650261351.png)





# 激活频道

## 激活

`目标`：

​	单击我的频道后要激活该频道，

​	即 弹出层关闭，同时home主页面要显示被单击频道的文章列表信息



`步骤`：

1. 在home/index.vue 中处理(之前已经设置过，强调下)

   ```vue
   <com-channel
         v-model="showChannel"
         :channelList="channelList"
         :activeChannelIndex.sync="activeChannelIndex"></com-channel>
   ```

   > 给activeChannelIndex设置sync调用，表示该属性可以被子组件修改

2. 在com-channel.vue中处理

   给弹出框的“我的频道”项目设置click单击事件

   ```vue
   <van-grid-item v-for="(item,k) in channelList" :key="item.id" 
                  @click="clkChannel(k)">
   ```

   > 把每个频道的下标序号作为参数进行传递

   在methods方法中实现单击逻辑
   
   ```js
   // 我的频道 单击后要激活显示该频道
   clkChannel (index) {
     // 1. 频道弹出层消失
     this.$emit('input', false)
     // 2. home/index.vue页面要"激活"当前单击到的频道并展示
     // 修改 activeChannelIndex的值为 index 即可(就是子组件修改父组件传递的变量)
     this.$emit('update:activeChannelIndex', index)
   },
   ```



现在单击**我的频道**的某个项目，就可以关闭弹出层，同时激活该项目并显示该项目的文章



`效果`：

![1580464760166](img(online)/1580464760166.png)



## 兼顾删除

`目标`：

​	删除**我的频道**的具体项目



如果当前频道处于**编辑**状态，那么指定频道被单击就应该是删除操作，而非激活显示……



`实现`：

在com-channel.vue中实现如下代码：

给弹出框的“我的频道”项目设置click单击事件，同时要求传递当前被单击项目的**频道参数**

```vue
<van-grid-item v-for="(item,k) in channelList" :key="item.id" 
               @click="clkChannel(item.id,k)">
```

在methods方法中实现单击逻辑

```js
// 我的频道 单击后要激活显示该频道
clkChannel (channelID, index) {
  // 判断有进入编辑状态，就执行删除逻辑，注意：“推荐”项目不要执行
  if (this.isEdit && index > 0) {
    this.userToRest(channelID, index)
    return false // 停止后续代码执行
  }

  // 1. 频道弹出层消失
  this.$emit('input', false)
  // 2. home/index.vue页面要"激活"当前单击到的频道并展示
  // 修改 activeChannelIndex的值为 index 即可(就是子组件修改父组件传递的变量)
  this.$emit('update:activeChannelIndex', index)
},
```


