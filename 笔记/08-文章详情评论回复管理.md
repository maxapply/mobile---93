

# 文章详情-评论-回复

# 详情

> 在首页可以看到文章列表信息，但是内容显示有限制
> 并没有显示全部内容，如果这对某个文章比较感兴趣，可以查看其全部信息
> 那么就需要制作一个详情页面，获取并展示文章详细信息

## 展示页面

> 组件：views/article/index.vue
> 路由：{path:'/article',component:xx}
>
> 展示逻辑：
> 1. 给路由配置文章id的参数，应用时候使用参数
> 2. 给列表中的每个文章制作click事件，使得单击跳转到详情页面
>     注意传递文章id参数
> 3. 给内部的click设置stop，阻止事件冒泡

`目标`：

​	点击 文章列表项目 跳转 到 展示详情页面

`步骤`：

1. 文章详情组件article/index.vue  已经创建好，可以执行前往查看 

2. 路由增加配置 router/index.js

   > 增加路由参数aid
   >
   > 增加name名称

   ```js
   {
     // 当前路由有参数，名称为aid
     path: '/article/:aid', // $router.push('/article/xxx') 该代码不太好维护
     name: 'article', // $router.push({name:'article',params:{aid:xx,aa:123,bb:456}}) 该代码更容易维护
     component: () => import('@/views/article/index.vue') // 文章详情
   },
   ```

   

3. 在 `home/components/com-article.vue` 中给文章列表设置click事件

   使得 单击 可以跳转显示详情页面

   ```html
   <!--文章列表项目-->
   <van-cell
             v-for="item in articleList"
             :key="item.art_id.toString()"
             :title="item.title"
             @click="$router.push({name:'article',params:{aid:item.art_id.toString()}})"
             >
   				 ………………
                 <!-- name="close"代表叉号
                   item.art_id.toString() 代表被处理的文章id信息
                   外部已经有click事件了，内部还有click事件
                   内部的click执行的时候，外部也会执行，导致内部失效，这是事件冒泡体现
                   处理：阻止事件冒泡
                   .stop是vue内部的修饰符，可以阻止事件冒泡
                 -->
              <van-icon
                   name="close"
                   style="float:right;"
                   @click.stop="displayDialog(item.art_id.toString())"
                 />
   ```
   
   > 1. 给van-cell 设置@click，使得文章项目具备单击效果
   >
   > 2. 给van-icon的@click设置**stop**调用，使得“阻止事件冒泡”，这样叉号图标被单击后就不向上传递事件，使得自己的单击效果得以保留
   >
   > 3. 给路由设置参数有如下两种方式：
   >
   >       $router.push('/article/'+item.art_id)
   >
   >       $router.push({name:'article', params:{aid:item.art_id}})
   >
   >       其中第二种方式比较好维护，推荐使用



`效果`：

![1580652383563](img(online)/1580652383563.png)

## 页面布局

`目标`：

​	绘制详情页面的基本结构



在 article/index.vue 中绘制如下内容

```vue
<template>
  <div class="container">
    <van-nav-bar fixed left-arrow @click-left="$router.back()" title="文章详情"></van-nav-bar>

    <div class="detail">
      <h3 class="title">美女与野兽</h3>
      <div class="author">
        <van-image
          round
          width="1rem"
          height="1rem"
          fit="fill"
          src="https://img.yzcdn.cn/vant/cat.jpeg"
        />
        <div class="text">
          <p class="name">一阵清风</p>
          <p class="time">两周内</p>
        </div>
        <van-button round size="small" type="info">+ 关注</van-button>
      </div>
      <div class="content">
        <p>文章内容文章内容文章内容</p>
      </div>
      <div class="zan">
        <van-button 
                    round 
                    size="small" 
                    class="active" 
                    plain 
                    icon="like-o" 
                    style="margin-right:8px;">点赞</van-button>
        <van-button round size="small" plain icon="delete">不喜欢</van-button>
      </div>
    </div>
    
  </div>
</template>
```

```vue
<script>
export default {
  // 每个组件name声明的名字【不要】与html标签重名，
  // 例如div、span、table，article、header、footer
  name: 'article-index'
}
</script>
```



```vue
<style scoped lang='less'>
.container {
  height: 100%;
  overflow-y: auto;
  box-sizing: border-box;
}
.detail {
  padding: 0 20px 88px;
  margin-top:92px;
  .title {
    font-size: 36px;
    line-height: 2;
  }
  .zan{
    text-align: center;
    padding: 20px 0;
    .active{
      border-color:red;
      color: red;
    }
  }
  .author {
    padding: 20px 0;
    display: flex;
    position:sticky;
    background-color: #fff;
    top:92px;
    z-index: 2;
    .text {
      flex: 1;
      padding-left: 20px;
      line-height: 1.5;
      .name {
        font-size: 14px;
        margin: 0;
      }
      .time {
        margin: 0;
        font-size: 12px;
        color: #999;
      }
    }
  }
  .content {
    padding: 40px 0;
    overflow: hidden;
    white-space: pre-wrap;
    word-break: break-all;
    p{
      font-size:28px;
    }
    /deep/ img{
      max-width:100%;
      background: #f9f9f9;
    }
    /deep/ code{
      white-space: pre-wrap;
    }
  }
}
</style>

```



`效果`：

![1581939115151](img(online)/1581939115151.png)

`说明`：

文章详情页面有4部分构成，标题、作者信息、文章内容、更多操作(点赞/不喜欢)



## 内容渲染

`目标`：

​	获取文章详情信息，并展示出来

`步骤`：

1. 在 `api/article.js` 创建获取文章的接口方法

   接口：【获取新闻文章详情】

   ```js
   /**
    * 根据文章id获得详情信息
    * @param {文章id} articleID
    */
   export function apiArticleDetail (articleID) {
     return request({
       url: '/app/v1_0/articles/' + articleID,
       method: 'get'
     })
   }
   ```
   

   
2. `article/index.vue`  中 做如下处理：

   > 1. 导入api
   > 2. 声明data
   > 4. 创建methods方法
   > 5. created
   
   ```vue
   <script>
   // 文章详情api
   import { apiArticleDetail } from '@/api/article.js'
   export default {
     name: 'article-index',
     data () {
       return {
         article: {} // 目标文章详情信息
       }
     },
     created () {
       // 自动调用
       this.getArticleDetail()
     },
     methods: {
       // 获得文章详情
       async getArticleDetail () {
         // 调用api获得文章详情
         const result = await apiArticleDetail(this.aid)
         this.article = result
       }
     }
   }
   </script>
   ```




   模板展示文章各个信息(标题、作者、作者头像、发布时间、是否关注、内容、点赞、不喜欢)

   ```vue
<!-- 标题、作者头像、作者名称、文章发表时间、关注、文章详情、是否喜欢、点赞 -->
<div class="detail">
  <h3 class="title">{{article.title}}</h3>
  <div class="author">
    <van-image round width="1rem" height="1rem" fit="fill" :src="article.aut_photo"/>
    <div class="text">
      <p class="name">{{article.aut_name}}</p>
      <p class="time">{{article.pubdate | formatTime}}</p>
    </div>
    <van-button round size="small" type="info">{{article.is_followed?'取消关注':'+ 关注'}}</van-button>
  </div>
  <div class="content">
    <p v-html="article.content"></p>
  </div>
  <div class="zan">
    <!--
class="active" 代表激活红色的样式
通过attitude属性值决定当前按钮是否有红框
plain： 表示按钮没有背景色，就是白底，但是有边框
icon="like-o" 给按钮设置图标
-->
    <van-button
                round
                size="small"
                :class="{active:article.attitude===1}"
                plain
                icon="like-o"
                style="margin-right:8px;"
                >点赞</van-button>
    <van-button
                round
                size="small"
                :class="{active:article.attitude===0}"
                plain
                icon="delete"
                >不喜欢</van-button>
  </div>
</div>
   ```

   

`效果`：

![1581939470876](img(online)/1581939470876.png)



## 关注和取消关注

> 如果针对当前作者比较感兴趣，可以对其进行关注
> 后端有智能算法，就把关注的人的文章多多地给推送出来
>
> 具体实现：
> 1. 制作api函数
> 业务组件 article/index.vue
> 1. 导入api
> 2. 给(取消)关注按钮设置click事件
> 3. methods方法进行(取消)关注活动
> 4. 优化，给关注按钮设置加载动画

`目标`：

​	实现对作者的 关注 和 取消关注 功能

`步骤`：

1. `api/user.js` 封装关注相关方法

   接口：【关注用户】

   ​			【取消关注用户】

   ```js
   /**
    * 针对某个作者进行关注
    * @param {被关注作者的id} target
    */
   export function apiUserFollow (target) {
     return request({
       url: '/app/v1_0/user/followings',
       method: 'post',
       data: {
         target
       }
     })
   }
   
   /**
    * 针对某个作者进行取消关注
    * @param {被取消关注作者的id} target
    */
   export function apiUserUnfollow (target) {
     return request({
       url: '/app/v1_0/user/followings/' + target,
       method: 'delete'
     })
   }
   ```
   
2. article/index.vue 中做如下配置

   template模板 部分

   > @click 单击事件绑定
   >
   > loading  是否显示加载效果
   
   ```vue
   <van-button
               round
               size="small"
               @click="followMe()"
               :loading="followLoading"
            		type="info"
               >
     				{{article.is_followed?'取消关注':'+ 关注'}}
   </van-button>
   
   ```
   
   

   

   script部分：

   > 导入api方法
   >
   > 声明data成员
   >
   > 创建关注methods方法  followMe：判断状态、关注操作、取消关注操作
   
   ```vue
   <script>
     // 关注相关api方法导入
     import { apiUserFollow, apiUserUnfollow } from '@/api/user.js'
     ……
     export default {
       name: 'article-index',
       data () {
         return {
           followLoading: false, // 关注加载标志
           ……
         }
       },
       methods: {
         // (取消)关注设置
         async followMe () {
           // 开启加载动画
           this.followLoading = true
   
           // 延迟时间
           await this.$sleep(1000)
   
           // 判断
           if (this.article.is_followed) {
             // 取消关注(成功率100%)
             await apiUserUnfollow(this.article.aut_id.toString())
             // 页面更新数据，使得响应式执行
             this.article.is_followed = false
           } else {
             // 关注(不是都成功，自己关注自己要失败，要做相关处理)
             try {
               await apiUserFollow(this.article.aut_id.toString()) // 有可能有错误
               this.article.is_followed = true // 不会有错误
             } catch (err) {
               if (err.response.status === 400) {
                 // return 就是停止后续代码执行
                 this.$toast.fail('自己不能关注自己！')
               } else {
                 this.$toast.fail('关注失败，请联系管理员')
               }
             }
           }
           // 回复按钮状态
           this.followLoading = false
         },
         ……
       }
     }
   </script>
   ```
   
   

`效果`：

![1580739539417](img(online)/1580739539417.png)



`注意`：

1. 用户必须**登录**后才可以关注其他用户
2. 自己**不能**关注自己



# 评论

> 评论功能业务逻辑相对比较复杂，处于开发、维护方便的角度考虑，把相关内容封装为**独立的组件**

## 页面布局设计

> 文章详情页面中，可以给文章进行评论操作
> 各个评论都是以列表形式呈现出来的
> 1. 现在要把“demo级”的评论列表展示出来
> 2. 评论信息有可能很多，要通过“瀑布流”给展示出来
> 3. 评论列表相对比较复杂，要形成“独立组件”维护
>
> 独立(子)组件：views/article/components/com-comment.vue
> (父)组件：views/article/index.vue
> 父对子要形成：导入、注册、使用关系

`目标`：

​	设计文章  demo评论列表  展示效果

1. 创建子组件 `article/components/com-comment.vue`  内容如下：

   > 主要内容效果是一个瀑布流

   ```vue
   <template>
     <div class="comment">
       <!--van-list：实现瀑布加载效果-->
       <van-list v-model="loading" :finished="finished" finished-text="没有更多了" @load="onLoad">
         <van-cell v-for="item in list" :key="item">
           <!-- 作者头像
             slot="icon" 是cell单元格命名插槽，自定义左侧图标
           -->
           <div slot="icon">
             <img class="avatar" src="http://toutiao.meiduo.site/Fn6-mrb5zLTZIRG3yH3jG8HrURdU" alt>
           </div>
           <!-- 作者名称
             slot="title" 是cell单元格命名插槽，左侧标题内容
           -->
           <div slot="title">
             <span>只是为了好玩儿</span>
           </div>
           <!-- 点赞
             slot="default" 是cell单元格命名插槽，右侧内容
           -->
           <div slot="default">
             <van-button icon="like-o" size="mini" plain>&nbsp;12</van-button>
           </div>
           <!-- 评论内容和时间
             slot="label" 是cell单元格命名插槽，下方描述信息
           -->
           <div slot="label">
             <p>hello world</p>
             <p>
               <span>2019-7-17 14:08:20</span>
               ·
               <span>4&nbsp;回复</span>
             </p>
           </div>
         </van-cell>
       </van-list>
     </div>
   </template>
   
   <script>
   export default {
     name: 'com-comment',
     data () {
       return {
         // 评论瀑布相关成员
         list: [], // demo数据
         loading: false, // 瀑布动画控制
         finished: false // 瀑布停止控制
       }
     },
     methods: {
       onLoad () {
         // 异步更新数据
         setTimeout(() => {
           for (let i = 0; i < 5; i++) {
             this.list.push(this.list.length + 1)
           }
           // 加载状态结束
           this.loading = false
   
           // 数据全部加载完成
           if (this.list.length >= 10) {
             this.finished = true
           }
         }, 500)
       }
     }
   }
   </script>
   
   <style lang="less" scoped>
   .comment{
     margin-top:15px;
     .avatar {
       width: 50px;
       height: 50px;
       border-radius: 100%;
       margin-right: 10px;
     }
     /deep/ .van-cell__title{
       .van-cell__label{
         width:400px;
       }
     }
   }
   </style>
   
   ```

   

2. 在 `article/index.vue`  中

   对com-comment.vue做 导入、注册、使用

   ```vue
         <!-- 评论列表，展示到文章详情区域里边,下方有两个闭合div -->
         <com-comment></com-comment>
       </div>
     </div>
   </template>
   
   <script>
   // 引入评论组件
   import ComComment from './components/com-comment.vue'
   ……
   export default {
     name: 'article-index',
     // 组件注册
     components: { ComComment },
   ```
```
   
   

`效果`：

![1580783826038](img(online)/1580783826038.png)



`注意`：

没有新技术，直接复制粘贴应用即可，把精力放到其它**业务**和**技术**上



## 内容渲染

> 根据当前文章获得真实的评论列表呈现
>
> 1. api制作(api/comment.js)
>
> 当前的api接口可以获得两部分信息：评论列表、回复列表
> 文章---->评论---->回复
> (评论是针对"文章"做的)
> (回复是针对"评论"做的)
>
> 获取信息传递条件：
> 评论列表：把当前“文章id”当参数条件进行传递
> 回复列表：把对应的“评论id”当参数条件进行传递
>
> 业务组件com-commnent.vue
> 1. 导入api
> 2. data
> 3. methods-->瀑布-->api-->data
> 4. 展示

`目标`：

​	获取当前文章的  所有评论  并展示

`步骤`：

1. 创建 `api/comment.js` 文件，创建接口方法获得评论列表

   接口：【获取评论或评论回复】

   ```js
   import request from '@/utils/request.js'
   
   /**
    * 获得"评论"列表
    * type 是 a或c 评论类型，a-对文章(article)的评论，c-对评论(comment)的回复
    * source:articleID 是  源id，文章id
    * offset 否  获取评论数据的【偏移量】，值为评论id，表示从此id的数据向后取，
    *            不传表示从第一页开始读取数据
    *            offset实现分页效果：
    *            offset=null       获得第1页数据，数据回来有一个last_id字段
    *            offset=last_id    获得第2页数据，数据回来有一个last_id字段
    *            offset=last_id    获得第3页数据，数据回来有一个last_id字段
    *            付出反复，offset始终等于上次数据回来的last_id字段内容，就可以不断获得下一页数据了
    *            offset/last_id    和  之前 的 timestamp /pre_timestamp作用类似，都是分页
    *        offset=null 获得第1页的5条数据,last_id=5  (id>0)
    *        offset=5    获得第2页的5条数据,last_id=10  (id>5)
    *        offset=10    获得第3页的5条数据,last_id=15 (id>10)
    *        offset=15    获得第4页的5条数据,last_id=20 (id>15)
    *        ……
    *        offset=偏移量    获得第n页的5条数据,last_id=20 (id>offset)
    * limit 否  获取的评论数据个数，不传表示采用后端服务设定的默认每页数据量
    */
   export function apiCommentList ({ articleID, offset }) {
     return request({
       url: '/app/v1_0/comments',
       method: 'get',
       params: {
         type: 'a',
         source: articleID,
         offset,
         limit: 10
       }
     })
   }
   
```

   > type:a    a:article   c:comment
   >          数据关系：文章--->(许多)评论--->(许多)回复
   > source: 文章id(type=a)、评论id(type=c)
   > offset: 分页标志
   >      offset=null    ----------> 第一页数据(返回last_id,代表最后一条评论信息的id)
   >      offset=last_id---------> 第二页数据(返回last_id)
   >      offset=last_id---------> 第三页数据(返回last_id)
   >      offset=last_id
   >      ……
   >      如此反复，就可以实现获得下页数据的分页功能了
   >
   > ​	功能类似之前学习的 timestamp  和 pre_timestamp
   >
   > limit: 每页数据条数

2. 在`article/components/com-comment.vue` 中  做处理

   > 1. 引入api方法
   > 2. 创建data
   > 4. methods(onLoad) 获得并应用  评论数据
   
   ```vue
   <script>
     // 获取文章评论api
     import { apiCommentList } from '@/api/comment.js'
     export default {
       name: 'com-comment',
       data () {
         return {
           // 评论相关
           commentList: [], // 评论列表
           offset: null, // 评论分页标志
   
           // 瀑布加载相关
           ……
         }
       },
       methods: {
         async onLoad () {
           await this.$sleep(800)
   
           // 根据文章id获得评论列表
           const comments = await apiCommentList({
             articleID: this.$route.params.aid,
             offset: this.offset
           })
           // 瀑布动画消失
           this.loading = false
   
           // 判断是否有获得到评论列表
           // comments.results: [{},{},{},……]
           if (!comments.results.length) {
             // 没有数据瀑布停止
             this.finished = true
             return false // 停止后续代码执行
           }
           // 有数据,给追加到 commentList成员里边
           this.commentList.push(...comments.results)
           // 对分页标志offset进行赋值
           this.offset = comments.last_id
         }
       }
     }
   </script>
   
   ```
   
   遍历展示评论信息(v-for、头像、作者名称、是否点赞、点赞数量、评论内容和时间、回复数量)
   
   ```vue
   <template>
     <div class="comment">
       <!--van-list：实现瀑布加载效果-->
       <van-list v-model="loading" :finished="finished" finished-text="没有更多了" @load="onLoad">
         <van-cell v-for="item in commentList" :key="item.com_id.toString()">
           <!-- 作者头像
             slot="icon" 是cell单元格命名插槽，自定义左侧图标
           -->
           <div slot="icon">
             <img class="avatar" :src="item.aut_photo" alt>
           </div>
           <!-- 作者名称
             slot="title" 是cell单元格命名插槽，左侧标题内容
           -->
           <div slot="title">
             <span>{{item.aut_name}}</span>
           </div>
           <!-- 点赞
             slot="default" 是cell单元格命名插槽，右侧内容
             danger:点赞，红色
             default:没有点赞，没有特殊颜色
           -->
           <div slot="default">
             <van-button icon="like-o" size="mini" plain
             :type="item.is_liking?'danger':'default'">&nbsp;{{item.like_count}}</van-button>
           </div>
           <!-- 评论内容和时间
             slot="label" 是cell单元格命名插槽，下方描述信息
           -->
           <div slot="label">
             <p>{{item.content}}</p>
             <p>
               <span>{{item.pubdate | formatTime}}</span>
               ·
               <span>{{item.reply_count}}&nbsp;回复</span>
             </p>
           </div>
         </van-cell>
       </van-list>
     </div>
   </template>
   ```
   
   


`效果`：

![1581941846076](img(online)/1581941846076.png)

`注意`：

1. 当前 com-comment.vue 组件的父级组件  article/index.vue 有路由参数，故也可以获取使用
2. last_id  是服务器返回用于获取后续**页码**评论信息的评论id，与之前的pre_timestamp是异曲同工之作
3. 为了使得文章有评论供使用，手动设置文章**路由参数id**为：  1203853076243415040



# 回复

## 页面布局设计

> 技术点：弹出层van-popup、瀑布流
>
> 回复列表相对也比较复杂，理论上要封装为独立组件
> 但是我们不要这样做，相反要把“回复列表全盘内容”直接放到
> 评论列表组件(com-comment.vue)内部，当然要使得评论列表组件相对更复杂一点
> 为什么回复不要设置为独立组件：
> 答：因为要为后期的添加评论、添加回复做铺垫

`目标`：

​	把**回复列表**的静态页面效果绘制出来



步骤：

1. 在article/components/com-comment.vue 中设置如下内容

   > 理论上，回复也较为复杂，应该设计为独立组件，但是考虑到后续的**添加回复、添加评论**要做兼容处理，就给合并到评论页面一并处理

   
   
   绘制回复列表区域：

   ```vue
    <!-- 回复列表展示-弹出层/瀑布 -->
       <van-popup v-model="showReply" position="bottom" :style="{ height: '80%' }" round>
        <!-- 瀑布加载效果 -->
         <van-list
                   v-model="reply.loading"
                   :finished="reply.finished"
                   finished-text="没有更多了"
                   @load="onLoadReply"
                   >
           <van-cell v-for="item in reply.list" :key="item" :title="item">
             <!-- 作者头像 -->
             <div slot="icon">
               <img class="avatar" 
                    src="http://toutiao.meiduo.site/Fn6-mrb5zLTZIRG3yH3jG8HrURdU" alt>
             </div>
             <!-- 作者名称 -->
             <div slot="title">
               <span>度娘</span>
             </div>
             <!-- 回复内容和时间 -->
             <div slot="label">
               <p>好厉害呀</p>
               <p>
                 <span>2019-12-30 15:15:15</span>
               </p>
             </div>
           </van-cell>
         </van-list>
       </van-popup>
     </div>
   </template>
   ```
   
   

   data部分：

   ```js
   
   data(){
    return {
       showReply: false, // 回复弹出层是否展示
       // 回复瀑布相关成员，通过reply成员包围，使得与外部的评论瀑布成员没有冲突
       reply: {
         list: [],
         loading: false, // 瀑布动画
         finished: false // 瀑布停止标志
       },
       ……
     }
   }
   
   ```
   
> 要通过reply衔接，避免与评论的冲突

   


methods方法

   ```js
   // 回复瀑布加载
   onLoadReply () {
     // 异步更新数据
     // setTimeout 仅做示例，真实场景中一般为 ajax 请求
     setTimeout(() => {
       for (let i = 0; i < 10; i++) {
         this.reply.list.push(this.reply.list.length + 1)
       }
   
       // 加载状态结束
       this.reply.loading = false
   
       // 数据全部加载完成
       if (this.reply.list.length >= 40) {
         this.reply.finished = true
       }
     }, 1000)
   },
   ```

   > 名称为onLoadReply，避免与评论的onLoad有冲突

   

   回复按钮设置click事件，使得单击展示回复弹出层：

   ```vue
   <span @click="showReply=true">{{item.reply_count}}&nbsp;回复</span>
   ```

   

`效果`：

![1580798643768](img(online)/1580798643768-1581952481468.png)



## 内容渲染

`目标`：

​	获取真实**回复列表数据**展示

`步骤`：

1. 在  `api/reply.js` 中封装api接口方法

   实现回复信息的获取操作

   接口：【获取评论或评论回复】  与 之前获得评论列表的一致

   ```js
   import request from '@/utils/request.js'
   
   /**
    * 获得"评论"列表
    * type 是 c  c-对评论(comment)获取的回复列表
    * source:commentID 是  源id，评论id
    * offset:lastID 否  获取评论数据的【偏移量】，值为评论id，表示从此id的数据向后取，
    *            不传表示从第一页开始读取数据
    *            offset实现分页效果：
    *            offset=null       获得第1页数据，数据回来有一个last_id字段
    *            offset=last_id    获得第2页数据，数据回来有一个last_id字段
    *            offset=last_id    获得第3页数据，数据回来有一个last_id字段
    *            付出反复，offset始终等于上次数据回来的last_id字段内容，就可以不断获得下一页数据了
    *            offset/last_id    和  之前 的 timestamp /pre_timestamp作用类似，都是分页
    * limit 否  获取的评论数据个数，不传表示采用后端服务设定的默认每页数据量
    */
   export function apiReplyList ({ commentID, lastID }) {
     return request({
       url: '/app/v1_0/comments',
       method: 'get',
       params: {
         type: 'c', // 获得回复列表标志
         source: commentID, // 评论id
         offset: lastID, // 偏移量，分页使用
         limit: 10
       }
     })
   }
   
   ```

2. article/components/com-comment.vue做处理

   script部分：

   > 导入api
   >
   > 创建data相关成员
   >
   > methods方法：展示回复弹出层、瀑布加载数据
   
   ```js
   // 获取评论回复【api】
   import { apiReplyList } from '@/api/reply.js'
   ……
   // 声明需要的【data】成员
   data () {
     return {
       // 回复相关
       commentID: '', // 被单击激活的评论
       lastID: null, // 分页标志(null、前一次返回的last_id)
       replyList: [], // 回复列表
       
       ……
   
   // 声明需要的【methods】方法
   methods:{
     // 单击回复标志，展示回复弹出层逻辑
     // 参数commentID：被激活的评论id
       openReply (commentID) {
         this.commentID = commentID
         this.showReply = true // 展开弹出层
   
         // 每次打开回复弹出层都要做初始化操作，把之前旧的"痕迹"都清除，使得新的回复信息得以展示
         this.replyList = [] // 旧的回复数据清除
         this.reply.finished = false // 激活瀑布
         this.lastID = null // 恢复分页偏移量
       },
         
       // 回复瀑布加载
       async onLoadReply () {
         await this.$sleep(800)
   
         // 获得回复列表数据(回复列表数据 与 评论列表数据 结构完全一致)
         const replys = await apiReplyList({
           commentID: this.commentID,
           lastID: this.lastID
         })
         // 瀑布加载动画消失
         this.reply.loading = false
         // 判断是否有数据
         if (!replys.results.length) {
           // 没有：瀑布停止
           this.reply.finished = true
           return false
         }
         // 有：追加 + offset
         this.replyList.push(...replys.results)
         this.lastID = replys.last_id // 维护分页偏移量
       },
   
         ……
   }
   
   ```
   
   template部分：
   
   ```vue
   <!--给回复按钮声明单击事件，传递评论id-->
   <span @click="openReply(item.com_id.toString())">{{item.reply_count}}&nbsp;回复</span>
   ```
   
   > 之前回复的click事件是简单语句，现在是methods方法，并有传递被激活评论id参数
   
   
   
   对回复数据做遍历展示
   
   ```vue
   <!-- 对获得到的回复信息做遍历展示 -->
   <van-cell v-for="item in replyList" :key="item.com_id.toString()" >
     <!-- 作者头像 -->
     <div slot="icon">
       <img class="avatar" :src="item.aut_photo" alt>
     </div>
     <!-- 作者名称 -->
     <div slot="title">
       <span>{{item.aut_name}}</span>
     </div>
     <!-- 回复内容和时间 -->
     <div slot="label">
       <p>{{item.content}}</p>
       <p>
         <span>{{item.pubdate | formatTime}}</span>
       </p>
     </div>
   </van-cell>
   ```

 


`效果`：

![1580801679830](img(online)/1580801679830-1581952481469.png)

`注意`：

​	获取回来的回复信息**字段名** 与 评论**字段名**完全一致



# 添加评论或回复

## 绘制操作构件

`目标`：

​	把添加  评论  或  回复  的**构件**绘制出来

`步骤`：

在`article/components/com-comment.vue`中做处理

1. 设置评论或回复的表单域小构件

   ```vue
       </van-popup>
       <!-- 添加评论或回复的小构件 -->
       <div class="reply-container van-hairline--top">
         <van-field v-model.trim="contentCorR" placeholder="写评论或回复...">
           <!-- slot="button"命名插槽，表明要给van-field的指定位置填充内容，button是输入框的右侧-->
           <van-button size="mini" :loading="submitting" slot="button">
             提交
           </van-button>
         </van-field>
       </div>
     </div>
   </template>
   ```

2. style设置样式

   ```css
   // 添加评论或回复构件
   .reply-container {
     position: fixed;
     left: 0;
     bottom: 0;
     height: 88px;
     width: 100%;
     background: #f5f5f5;
     z-index: 9999;
   }
   ```
   
3. data成员  (与van-field的v-model结合) ：

   ```js
   data(){
     return {
       // 添加评论或回复成员
       contentCorR: '', // 内容
       submitting: false, // 是否正在提交
       
       ……
     }
   }

   ```
   
   

`效果`：

![1584060119706](img(online)/1584060119706.png)



`注意`：

​	添加评论、添加回复 使用的是同一个表单域，后续要做**兼容**处理



## 具体实现

`目标`：

​	实现添加  评论或回复  的功能



`分析`：

​	评论和回复 一并处理，需要判断当前是 评论 还是 回复，可以根据 `showReply` 做判断，showReply为true就是回复，为false就是评论



`步骤`：

1. 在api/reply.js 中创建api方法

   接口：【添加评论或评论回复】

   ```js
   /**
    * 添加评论或回复信息 (接口：【添加评论或评论回复】)
    * @param {*} target 文章或评论的id（评论文章即为 文章id，对评论进行回复则为 评论id）
    * @param {*} content 评论或回复的内容
    * @param {*} artID 文章id，对评论内容发表回复时，需要传递此参数，表明所属文章id。
    *                    对文章进行评论，不要传此参数
    * C:comment评论
    * R:reply回复
    */
   export function apiAddCorR ({ target, content, artID = null }) {
     return request({
       url: '/app/v1_0/comments',
       method: 'POST',
       data: {
         target,
         content,
         art_id: artID
       }
     })
   }
   
   ```

   

3. 在article/components/com-comment.vue中做如下处理

   给提交按钮绑定click事件

   ```vue
<span class="submit" v-else slot="button" @click="add">提交</span>
   ```
   
   导入 添加评论/回复 信息的api方法 apiAddCorR

   ```js
// 获取评论回复api、添加评论/回复
   import { apiReplyList, apiAddCorR } from '@/api/reply.js'
   ```
   
   methods方法实现添加逻辑
   
   ```js
   // 添加 评论 或 回复
   async add () {
     // 没有输入内容
     if (!this.contentCorR) return false
   
     // 开启提交中
     this.submitting = true
   
     // 暂停0.8秒
     await this.$sleep(800)
   
     if (this.showReply) {
       // A. 回复
       // target: this.commentID, 被激活评论id
       // content: this.contentCorR,回复内容
       // art_id: this.aid 当前文章id
       const result = await apiAddCorR({
         target: this.commentID,
         content: this.contentCorR,
         artID: this.$route.params.aid
       })
       // result里边可以访问new_obj成员，代表被新添加的回复的对象内容
       // 在回复列表顶部追加  回复信息(新回复信息置顶显示)，使得可以立即展示(响应式)
       this.replyList.unshift(result.new_obj)
       // 找到当前回复的评论项目，对回复的数量进行累加操作
       // find()可以从大的"数组对象集"中获得某一个小对象
       //       这个小对象是引用传递出来的，外部对其进行修改
       //       数组对象集内部可以感知到
       const comment = this.commentList.find(
         item => item.com_id.toString() === this.commentID
       )
       comment.reply_count++ // 回复数量累加
     } else {
       // B. 评论
       const result = await apiAddCorR({
         target: this.$route.params.aid,
         content: this.contentCorR
       })
       // 在评论顶部追加  评论信息(新评论信息置顶显示)
       this.commentList.unshift(result.new_obj)
     }
   
     // 清除输入框
     this.contentCorR = ''
     // 结束提交中
     this.submitting = false
   },
   ```
   
   > 通过showReply的boolean值，可以知道当前是评论 和 回复 



`效果`：

![1580806584436](img(online)/1580806584436-1581952481470.png)

![1580806640373](img(online)/1580806640373-1581952481470.png)












