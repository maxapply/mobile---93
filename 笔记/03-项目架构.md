#约定路由规则

| path           | 功能           | 路由级别 |
| -------------- | -------------- | -------- |
| /              | 布局组件layout | 一级路由 |
| ├─ /home       | 首页组件       | 二级路由 |
| ├─ /question   | 问答组件       | 二级路由 |
| ├─ /video      | 视频组件       | 二级路由 |
| ├─ /user       | 个人中心组件   | 二级路由 |
| /user/profile  | 编辑资料组件   | 一级路由 |
| /user/chat     | 小智同学组件   | 一级路由 |
| /login         | 登录组件       | 一级路由 |
| /search        | 搜索中心组件   | 一级路由 |
| /search/result | 搜索结果组件   | 一级路由 |
| /article       | 文章详情       | 一级路由 |

- 根据参考图，设计路由规则。

上述路由 home、question、video、user 它们需要使用共同的头部、脚步内容，这个头部、脚步为了开发、维护方便已经在layout布局组件中一次性配置好了，所以这个4个组件内容需要与layout构成父子关系，它们的路由都是二级的子路由模式



#实现路由配置

`router/index.js`：

```js
import Vue from 'vue'
import VueRouter from 'vue-router'

Vue.use(VueRouter)

const routes = [
  {
    path: '/',
    component: () => import('@/views/layout/index.vue'), // 布局组件  一级路由
    redirect: '/home', // 重定向
    children: [
      {
        path: '/home',
        component: () => import('@/views/home/index.vue') // 首页组件 二级路由
      },
      {
        path: '/question',
        component: () => import('@/views/question/index.vue') // 问答组件  二级路由
      },
      {
        path: '/video',
        component: () => import('@/views/video/index.vue') // 视频组件  二级路由
      }, {
        path: '/user',
        component: () => import('@/views/user/index.vue') // 个人中心  二级路由
      }
    ]
  },
  {
    path: '/user/profile',
    component: () => import('@/views/user/profile.vue') // 编辑资料
  },
  {
    path: '/user/chat',
    component: () => import('@/views/user/chat.vue') // 小智同学
  },
  {
    path: '/login',
    name:'login',
    component: () => import('@/views/user/login.vue') // 登录
  },
  {
    path: '/article',
    component: () => import('@/views/article/index.vue') // 文章详情
  },
  {
    path: '/search',
    component: () => import('@/views/search/index.vue') // 搜索中心
  },
  {
    path: '/search/result',
    component: () => import('@/views/search/result.vue') // 搜索结果
  }
]

const router = new VueRouter({
  routes
})

export default router

```

- 根据约定的路由规则定义。
- 且先定义规则对应的组件。



#完成Layout组件

`layout/index.vue`

```vue
<template>
  <div class="container">
    <!-- 公共头部
    van-nav-bar是 导航栏组件，
    title：导航中间呈现内容
    right-text：导航右侧呈现内容
    @click-right：右侧文字单击后发生的事件
    fixed：固定定位，定位到页面头部，是样式体现(postion:fixed;top:0;left:0;)
    -->
    <van-nav-bar fixed title="黑马头条" right-text="搜索"
      @click-right="$router.push('/search')"/>

    <div class="my-wrapper" >
      <!--路由占位符，用于显示 home、question、video、user的组件的-->
      <router-view></router-view>
    </div>

    <!-- 公共脚步
      van-tabbar:标签栏组件
      van-tabbar: route  激活路由功能
      van-tabbar-item
        to: 请求路由地址
        icon：标签栏项目显示的图标，icon图标库在组件库中可以看到
    -->
    <van-tabbar route>
      <van-tabbar-item to="/home" icon="home-o">首页</van-tabbar-item>
      <van-tabbar-item to="/question"  icon="chat-o">问答</van-tabbar-item>
      <van-tabbar-item to="/video"  icon="video-o">视频</van-tabbar-item>
      <van-tabbar-item to="/user"  icon="user-o">我的</van-tabbar-item>
    </van-tabbar>
  </div>
</template>

<script>
export default {
}
</script>

<style scoped lang='less'>
.container{
  width: 100%;
  height: 100%;
  position: relative;
  .my-wrapper{
    width: 100%;
    height: 100%;
    overflow: hidden;
    padding-top: 92px;
    padding-bottom: 100px;
    box-sizing: border-box;
    &.noTop{
      padding-top: 0;
    }
  }
}
</style>

```

- 提供  首页 问答 视频 我的  基础布局，也就是一级路由组件。
- 回退历史，需要根据地址栏去选中TabBar对应标签，开启路由模式组件内部实现。
- 点击搜索，跳转到搜索中心页面。





# 全局样式

`src/assets/css/global.less`

```less
// -----------------------全局样式-----------------------
*{
  margin: 0;
  padding: 0;
}
ul{
  list-style: none;
}
#app{
  position: absolute;
  left: 0;
  top: 0;
  overflow: hidden;
  width: 100%;
  height: 100%;
  font-size: 28px;
}

// -----------------------覆盖vant-导航栏组件默认样式的-----------------------
.van-nav-bar {
  background-color: #1989FA;
  .van-nav-bar__title {
    color: #fff;
  }
  .van-nav-bar__text {
    color: #fff;
    font-size: 12px;
  }
  .van-icon{
    color: #fff;
  }
}
.van-tabbar{
  background: #fdfdfd;
}
.van-nav-bar__text:active{
  background: transparent;
}

```

main.js中在引入vant样式后，导入自己样式，这样覆盖。

```js
// 导入全局样式控制文件
// 注意：在vant的css样式导入之后设置
import '@/assets/css/global.less'
```

> 注意：要在 vant样式之后引入
>



App.vue组件内容如下(去除h2标签和其他示意内容)：

```vue
<template>
  <div id="app">
    <!--路由占位符-->
    <router-view></router-view>
  </div>
</template>

<script>
export default {
  name: 'app'
}
</script>

<style lang="less" scoped>
</style>

```



`效果`：

![1583071385890](img(online)/1583071385890.png)



#其他功能组件

home/index.vue 组件

```vue
<template>
  <div class='container'>Home</div>
</template>

<script>
export default {
  name: 'home-index'
}
</script>

<style scoped lang='less'></style>
```

question/index.vue 组件

```vue
<template>
  <div class='container'>
    <!-- van-skeleton：骨架屏组件
      title：第一行标题骨架
      :row="3" 后边还有3行骨架
     -->
    <van-skeleton title :row="3" />
    <van-skeleton title :row="3" />
    <van-skeleton title :row="3" />
  </div>
</template>

<script>
export default {
  name: 'question-index'
}
</script>

<style scoped lang='less'>
.van-skeleton{
  margin-top: 10px;
}
</style>

```

video/index.vue 组件

```vue
<template>
  <div class='container'>
    <!-- avatar：骨架屏前边有圆圈 -->
    <van-skeleton title avatar :row="3" />
    <van-skeleton title avatar :row="3" />
    <van-skeleton title avatar :row="3" />
  </div>
</template>

<script>
export default {
  name: 'video-index'
}
</script>

<style scoped lang='less'>
.van-skeleton{
  margin-top: 10px;
}
</style>
```

user/index.vue 组件

```vue
<template>
  <div class='container'>User</div>
</template>

<script>
export default {
  name: 'user-index'
}
</script>

<style scoped lang='less'></style>
```

search/index.vue 组件

```vue
<template>
  <div class="container">
    <van-nav-bar title="搜索中心" left-arrow @click-left="$router.back()" />
  </div>
</template>

<script>
export default {
  name: 'search-index'
}
</script>

<style scoped lang='less'></style>
```

search/result.vue 组件

```html
<template>
  <div class='container'>
    <van-nav-bar title="搜索结果" left-arrow @click-left="$router.back()" />
  </div>
</template>

<script>
export default {
  name: 'search-result'
}
</script>

<style scoped lang='less'></style>
```

user/profile.vue 组件

```vue
<template>
  <div class="page-user-profile">
    <van-nav-bar 
                 left-arrow 
                 @click-left="$router.back()" 
                 title="编辑资料" 
                 right-text="保存"></van-nav-bar>
  </div>
</template>

<script>
export default {
  name:'user-profile',
}
</script>

<style scoped lang='less'></style>
```

user/chat.vue 组件

```vue
<template>
  <div class="container">
    <van-nav-bar fixed left-arrow @click-left="$router.back()" title="小智同学"></van-nav-bar>
  </div>
</template>

<script>
export default {
  name: 'user-chat'
}
</script>

<style scoped lang='less'></style>

```

user/login 组件

```vue
<template>
  <div class="user-login">
    <van-nav-bar title="登录"></van-nav-bar>
  </div>
</template>

<script>
export default {
  name: 'user-chat'
}
</script>

<style scoped lang='less'></style>

```

article/index  详情组件

```html
<template>
  <div class='container'>
    <van-nav-bar fixed left-arrow @click-left="$router.back()" title="文章详情">
    </van-nav-bar>
  </div>
</template>

<script>
export default {
  name: 'article'
}
</script>

<style scoped lang='less'></style>

```



#vuex管理账户信息

`src/store.js`

通过vuex操作localStorage实现token数据的管理

localStorage是浏览器技术，本身没有响应式，用户体验不好，相反vuex有此功效，并且vuex的数据可以被vue很好的监听



实际达成效果如下：

![1579610782507](img(online)/1579610782507.png)

1. 用户组件直接操控vuex
2. vuex操控localStorage实现用户token等信息的管理
3. 服务器端返回的token等信息要被  Vuex 和 localStorage  两个地方接管
4. Vuex有响应式，数据变化了马上可以感知，localStorage持久存储，页面关闭或刷新数据不会丢失



```js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)
// localStorage 存储用户信息的key名称，统一设置，方便后续使用
const USER_KEY = 'hm-toutiao-mobile-user'

export default new Vuex.Store({
  state: {
    // 通过 || 设定，如果localStorage没有数据，就返回{}空对象
    user: JSON.parse(localStorage.getItem(USER_KEY) || '{}')
  },
  mutations: {
    // 修改/更新用户信息
    // data:{token:xx,refresh_token:xx}
    updateUser (state, data) {
      // 1. vuex做更新，使得有响应式
      state.user = data
      // 2. localStorage做持久更新
      localStorage.setItem(USER_KEY, JSON.stringify(data))
    },
    // 清除用户信息
    clearUser (state) {
      // 1. vuex做清除，使得有响应式
      state.user = {}
      // 2. localStorage做持久清除
      localStorage.removeItem(USER_KEY)
    }
  },
  actions: {
  },
  modules: {
  }
})

```





#axios封装

封装的目的：

​	复用，导出一个可以被其他应用重复调用的axios函数对象。

这个axios对象已经把如下公共配置做好：

- 处理JS最大整型数值问题
- 处理在请求头中携带token
- 处理响应数据（剥离无效数据）
- 导出一个使用配置好的axios发请求的函数



![1579658370936](img(online)/1579658370936.png)



## 安装axios和bigint

```bash 
npm i axios json-bigint
```

## 对axios进行封装 封装request.js

创建文件 `src/utils/request.js` 用于配置axios

axios.defaults 是对本身axios 进行改造

axios.create 是创建了一个axios实例 ,和原来的axios没有关系了

```js
// 对axios进行相关配置
import axios from 'axios'
import JSONBig from 'json-bigint'

// 导入store(vuex) 用于获取用户信息
// store.state.user 获取用户信息
// store.commit(xx,yy)  调用mutations方法
// store.dispatch(xx,yy)  调用actions方法
import store from '@/store/index.js'

// 导入路由，使得可以执行路由跳转(编程式导航)
// router.push(xx)
import router from '@/router/index.js'

// 创建一个axios实例 和原来的axios没有关系
// create()调用完毕会返回一个"新的axios对象"(instance接收)
// "新的axios对象" 与原生的axios没有任何关系
// 给instance做各种配置应用，原生的axios对象不会做任何"污染"
// 这样不影响原生axios对象再其他场合的应用
const instance = axios.create()

// 对外导出axios对象
export default instance

```

> 把store导入进来后边据此判断用户是否处于登录状态



## 设置baseUrl和处理大数字

```js
// 创建一个axios实例 和原来的axios没有关系
// create()调用完毕会返回一个"新的axios对象"(instance接收)
// "新的axios对象" 与原生的axios没有任何关系
// 给instance做各种配置应用，原生的axios对象不会做任何"污染"
// 这样不影响原生axios对象再其他场合的应用
// instance.defaults.baseURL = xx
// instance.defaults.transformResponse = []

const instance = axios.create({
  // 请求公共根地址
  baseURL: 'http://ttapi.research.itcast.cn/',
  // 超大整型数字转换器
  transformResponse: [function (data) {
    // 服务器端返回的data数据是字符串
    // 1. 实体字符串 "{name:value,name:value,name:value}""
    // 2. 空壳字符串 ""

    // if (data) {
    //   return JSONBig.parse(data)
    // } else {
    //   return data
    // }

    try {
      // 成功：实体字符串
      // 失败：空壳字符串
      return JSONBig.parse(data)
    } catch (err) {
      // 步骤失败
      return data
    }
  }]
})
```

> axios并不是每次请求都有返回实体数据，有的请求会返回""空字符串信息，这样JSONBig.parse()处理不了，就报错了，catch会捕获并做处理



## 在请求拦截器注入token

```js
// 配置【请求拦截器】
instance.interceptors.request.use(function (config) {
  // 判断token存在再做配置(vuex判断)
  // store.user.token 根据是否有值，就知道用户是否登录系统
  if (store.state.user.token) {
    // 注意：token前边有 'Bearer ' 的信息前缀
    config.headers.Authorization = 'Bearer ' + store.state.user.token
  }
  return config
}, function (error) {
  // Do something with request error
  return Promise.reject(error)
})
```

> 判断用户处于登录状态，再配置token

## 在响应拦截器处理返回数据、401处理

```js
// 配置【响应拦截器】
// f1(10,20)
instance.interceptors.response.use(function (response) {
  // 正常响应处理
  // 确认服务器端返回的数据：返回data、返回data.data
  // const result = await axios()
  // this.xxx = result
  try {
    // data.data如果报错，没有获得到，错误信息会被catch步骤，就走data了
    return response.data.data
  } catch (err) {
    return response.data
  }
}, function (error) {
  // 非正常响应处理(包括401)
  // console.dir(error) // 对象： config request response isAxiosError toJSON
  if (error.response.status === 401) {
    // token不ok(token在服务器端已经失效了，2个小时时效)
    // 强制用户重新登录系统，以刷新服务器端的token时效
    router.push('/login')
    // 不要给做错误提示了
    return new Promise(function () {}) // 空的Promise对象，没有机会执行catch，进而不做错误提示了
  }

  // return new Promise((resolve,reject)=>{
  //    reject('获得文章失败！')
  // })
  return Promise.reject(error)
})
```

> 通过之前学习指导，axios返回的数据信息里边，都要通过data或data.data获得业务数据，我们就把这个data给封装一下，使得业务应用场合获取到直接的业务数据，使得开发更高效



* **`完整代码`**

```js
// 对axios进行相关配置
import axios from 'axios'
import JSONBig from 'json-bigint'

// 导入store(vuex) 用于获取用户信息
// store.state.user 获取用户信息
// store.commit(xx,yy)  调用mutations方法
// store.dispatch(xx,yy)  调用actions方法
import store from '@/store/index.js'

// 导入路由，使得可以执行路由跳转(编程式导航)
// router.push(xx)
import router from '@/router/index.js'

// 创建一个axios实例 和原来的axios没有关系
// create()调用完毕会返回一个"新的axios对象"(instance接收)
// "新的axios对象" 与原生的axios没有任何关系
// 给instance做各种配置应用，原生的axios对象不会做任何"污染"
// 这样不影响原生axios对象再其他场合的应用
// instance.defaults.baseURL = xx
// instance.defaults.transformResponse = []

const instance = axios.create({
  // 请求公共根地址
  baseURL: 'http://ttapi.research.itcast.cn/',
  // 超大整型数字转换器
  transformResponse: [function (data) {
    // 服务器端返回的data数据是字符串
    // 1. 实体字符串 "{name:value,name:value,name:value}""
    // 2. 空壳字符串 ""

    // if (data) {
    //   return JSONBig.parse(data)
    // } else {
    //   return data
    // }

    try {
      // 成功：实体字符串
      // 失败：空壳字符串
      return JSONBig.parse(data)
    } catch (err) {
      // 步骤失败
      return data
    }
  }]
})

// 配置【请求拦截器】
instance.interceptors.request.use(function (config) {
  // 判断token存在再做配置(vuex判断)
  // store.user.token 根据是否有值，就知道用户是否登录系统
  if (store.state.user.token) {
    // 注意：token前边有 'Bearer ' 的信息前缀
    config.headers.Authorization = 'Bearer ' + store.state.user.token
  }
  return config
}, function (error) {
  // Do something with request error
  return Promise.reject(error)
})

// 配置【响应拦截器】
// f1(10,20)
instance.interceptors.response.use(function (response) {
  // 正常响应处理
  // 确认服务器端返回的数据：返回data、返回data.data
  // const result = await axios()
  // this.xxx = result
  try {
    // data.data如果报错，没有获得到，错误信息会被catch步骤，就走data了
    return response.data.data
  } catch (err) {
    return response.data
  }
}, function (error) {
  // 非正常响应处理(包括401)
  // console.dir(error) // 对象： config request response isAxiosError toJSON
  if (error.response.status === 401) {
    // token不ok(token在服务器端已经失效了，2个小时时效)
    // 强制用户重新登录系统，以刷新服务器端的token时效
    router.push('/login')
    // 不要给做错误提示了
    return new Promise(function () {}) // 空的Promise对象，没有机会执行catch，进而不做错误提示了
  }

  // return new Promise((resolve,reject)=>{
  //    reject('获得文章失败！')
  // })
  return Promise.reject(error)
})

// 对外导出axios对象
export default instance

```

- **`公共根地址`**
- **`最大安全整数处理`**
- **`token请求头携带`**
- **`响应数据  获取有效数据 处理,处理data或data.data`**
- **`401状态码简单处理`**
- **`导出`**



##401状态码升级处理【后边讲】

> 401 服务器端返回状态码，代表当前用户没有登录系统
> 系统中有些请求要求用户必须登录状态，才可以使用(例如添加评论)
> 现在是通过客户端中是否有token数据判断用户是否有登录系统
>
> 目前处理：如果服务器端报401错误，就暴力解决使其强制登录
> (并不是说所有401都代表用户是非登录的，有时即使出现401，
>  用户的登录状态其是是ok的，这样就不要强制登录 )
> 频繁强制登录造成用户体验不好
>
> 系统中出现10次 401，可能有9次都不用强制登录的
>
> 现在要给401做升级处理
> token：服务器端给客户端返回的秘钥信息，用以标志登录状态
> refresh_token：秘钥信息，作用：token 失效后可以去营救
>
> token：有效期是2小时(服务器端规定)
> refresh_token：有效期是14天(服务器端规定)
>
> token失效了(2小时过期了，与操作没有关系)，
> 可以利用refresh_token继续向服务器端发请求
> 此时会返回一个有效的token(有效期又刷新为延续2小时)
> 此时可以维护新的token做应用即可
> 目前情形可以不用强制登录
>
> 如果refresh_token也过期了，就强制登录吧
>
> 401升级处理逻辑(refresh_token可以营救token)：
> 模拟2小时token过期
> 1. 制作vuex mutations方法，专门删除token(refresh_token还有保留)
> 2. 页面制作button按钮调用这个方法
>
> 3. 发表评论，服务器端返回401，
>     refresh_token去营救token
>     营救成功--->把之前发表评论失败的请求再重新发送一次

`目标`：

​	知道401状态码的意思和处理



axios向服务器端发送请求时有两种情况会出现401状态码(unauthorized未授权)：

1. 服务端要求传递token信息，而实际没有传递
2. 我们有传递token到达服务器端，但由于时间比较久，这个token在服务器中已经过期了(服务器存储token有效期时间为2个小时)

总之，服务器端有些api接口要求传递token，token失效或没有传递，就会报401错误

相关处理：

1. 第1种情况，已经在**axios请求拦截器**中做token传递操作了

2. 第2种情况，之前是这样处理的，在**axios响应拦截器**中判断请求状态如果是401，就强制用户**重新登录**系统

   这样处理用户体验非常不好，现在做一次升级优化处理



服务器端返回两个秘钥信息，它们在服务端都有使用时效

`token` 有效期2小时

`refresh_token` 有效期14天

refresh_token用于在token过期后，重新获取并刷新token时效使用的

针对第2种401状态码处理步骤为：

1. 判断refresh_token是否存在
   1. 不存在就直接重新登录
   2. 存在，axios发起请求，带着refresh_token请求服务端，获取新token火来
      1. 成功：对vuex和localStorage进行token信息更新
         1. 把之前的失败请求重新发送给服务器端
      2. 失败：清空无效用户信息，直接重新登录
   

![1582188388900](img(online)/1582188388900.png)



具体实现：

1. 给store/index.js创建一个mutations方法，模拟token已经失效(2小时有效)

   ```js
   mutations:{
     // 模拟删除token数据，
     clearToken (state) {
       delete state.user.token
     }
   }
   
   ```
   
2. 在文章详情页面`article/index.vue` 中创建一个button按钮，调用步骤1的方法

   ```vue
   <van-button @click="$store.commit('clearToken')">模拟删除token</van-button>
   ```
   
3. `utils/request.js`中响应拦截器代码升级为如下：

   ```js
   // 配置【响应拦截器】
   // f1(10,20)
   instance.interceptors.response.use(function (response) {
     // 正常响应处理
     // 确认服务器端返回的数据：返回data、返回data.data
     // const result = await axios()
     // this.xxx = result
     try {
       // data.data如果报错，没有获得到，错误信息会被catch步骤，就走data了
       return response.data.data
     } catch (err) {
       return response.data
     }
   }, async function (error) {
     // 非正常响应处理(包括401)
     // console.dir(error) // 对象： config request response isAxiosError toJSON
     if (error.response.status === 401) {
       // refresh_token去营救token
       // 1. 判断refresh_token如果也没有，强制登录
       if (!store.state.user.refresh_token) {
         router.push('/login')
         // return 停止后续代码执行
         return new Promise(function () {}) // 返回空壳的对象，不要报任何错误
       }
   
       // 2. refresh_token存在，就携带者，发送新的axios请求，去营救token
       //    如果此时服务器端的refresh_token已经失效了(14天过了)，同样返回401，就强制登录
       //    所以要给下述代码设置try/catch，捕捉401并处理
       try {
         // axios有可能产生错误，就被catch捕捉
         const result = await axios({
           url: 'http://ttapi.research.itcast.cn/app/v1_0/authorizations',
           method: 'put',
           // 配置请求头信息
           headers: {
             // 配置refresh_token
             Authorization: 'Bearer ' + store.state.user.refresh_token
           }
         })
   
         // 下述代码不会错误
         // 注意：服务器端没有返回refresh_token，还使用当前的
         // console.log(result)/  / 营救好的token  result.data.data.token
         // 客户端对新的token进行维护，vuex维护，token和refresh_token必须同时维护
         store.commit('updateUser', {
           token: result.data.data.token,
           refresh_token: store.state.user.refresh_token
         })
   
         // 把刚刚401失败的请求再重新发送一次
         // error.config：拥有失败请求的相关信息 {url,method,data等等}
         // 该信息正好可以满足axios应用
         // console.dir(error)  // {url,method,data等等}
         // instance是拥有许多配置信息的axios对象
         return instance(error.config)
       } catch (err) {
         // 清除无效的refresh_token
         store.commit('clearUser')
         // token不ok(token在服务器端已经失效了，2个小时时效)
         // 强制用户重新登录系统，以刷新服务器端的token时效
         router.push('/login')
         // 不要给做错误提示了
         return new Promise(function () {}) // 空的Promise对象，没有机会执行catch，进而不做错误提示了
       }
     }
   
   ```

现在给用户的体验就非常好，token两个小时过期后，refresh_token可以帮忙营救刷新token，使得用户无需强制退出，就完成了请求操作（期间 用户还感觉自己始终是处于登录状态呢）



